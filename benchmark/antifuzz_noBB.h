#ifndef ANTIFUZZ_H
#define ANTIFUZZ_H
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>

#define FLAG_FILLBITMAP 1
#define FLAG_HEAVWEIGHTBB 2
#define FLAG_SIGNAL_TAMPERING 4
#define FLAG_ANTI_DEBUGGING 8
#define FLAG_AFL FLAG_FILLBITMAP
#define FLAG_TFUZZ FLAG_FILLBITMAP
#define FLAG_DRILLER FLAG_FILLBITMAP
#define FLAG_VUZZER FLAG_HEAVWEIGHTBB
#define FLAG_KLEE FLAG_HEAVWEIGHTBB
#define FLAG_ZZUF FLAG_SIGNAL_TAMPERING
#define FLAG_ALL FLAG_FILLBITMAP | FLAG_HEAVWEIGHTBB | FLAG_SIGNAL_TAMPERING | FLAG_ANTI_DEBUGGING

#define USE_ANTIFUZZ 1
#define USE_FILLBITMAP 0
#define USE_HEAVYWEIGHTBB 0
#define DETECT_AFL 0
#define DETECT_QEMU 0
#define DETECT_PIN 0
#define FOR_CGC 0
#define ENABLE_SLEEP 0
#define DIFFICULTY_LEVEL 4
#define ANTIFUZZ_SLEEP 750
#define ANTIFUZZ_SLEEP_CRASH 750
#define USE_SIGNAL_TAMPERING (1 && !FOR_CGC)
#define USE_HASH_CMP 0
#define USE_ANTI_DEBUGGING (0 && !FOR_CGC)
#define USE_ENCRYPT_DECRYPT 0
#define ZZUF_OUTPUT_QUEUE_FILE 0
#define REPLACE_UTMP 0

#define INCLUDE_UNISTD 1

#define ANTIFUZZ_CRASH_ACTION_SLEEP_UNTIL_TIMEOUT 0
#define ANTIFUZZ_CRASH_ACTION_EXIT_GRACEFULLY 1 
#define IF_CRASH_THEN_DO 1

#define SLEEP_METHOD_BUSY_WAITING 0
#define SLEEP_METHOD_TRADITIONAL 1
#define SLEEP_METHOD 0

#define ENABLE_PRINTF 1

#if USE_HASH_CMP
/*
 * sha512.h - interface to mbedTLS SHA512 hash function.
 *
 * Copyright 2017 Google Inc.
 * Author: Joe Richey (joerichey@google.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#ifndef SHA512_H
#define SHA512_H

#include <stddef.h>
#include <stdint.h>

#define SHA512_DIGEST_LENGTH 64

extern void SHA512(const uint8_t* in, size_t n,
                   uint8_t out[SHA512_DIGEST_LENGTH]);

// Zero the memory pointed to by v; this will not be optimized away.
extern void secure_wipe(uint8_t* v, uint32_t n);

#endif /* SHA512_H */

/*
 * sha512.c - mbed TLS (formerly known as PolarSSL) implementation of SHA512
 *
 * Modifications Copyright 2017 Google Inc.
 * Modifications Author: Joe Richey (joerichey@google.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 *  FIPS-180-2 compliant SHA-512 implementation
 *
 *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
 *  SPDX-License-Identifier: Apache-2.0
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may
 *  not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  This file is part of mbed TLS (https://tls.mbed.org)
 */
/*
 *  The SHA-512 Secure Hash Standard was published by NIST in 2002.
 *
 *  http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf
 */


#include <string.h>  // (memset_s or explicit_bzero if available)

#if defined(_MSC_VER) || defined(__WATCOMC__)
#define UL64(x) x##ui64
#else
#define UL64(x) x##ULL
#endif

/* We either use dedicated memory clearing functions or volatile dereference. */
void secure_wipe(uint8_t *v, uint32_t n) {
#if defined memset_s
  memset_s(v, n, 0, n);
#elif defined explicit_bzero
  explicit_bzero(v, n);
#else
  volatile uint8_t *p = v;
  while (n--) *p++ = 0;
#endif
}

/*
 * SHA-512 context structure
 */
typedef struct {
  uint64_t total[2];         /*!< number of bytes processed  */
  uint64_t state[8];         /*!< intermediate digest state  */
  unsigned char buffer[128]; /*!< data block being processed */
} mbedtls_sha512_context;

/*
 * 64-bit integer manipulation macros (big endian)
 */
#ifndef GET_UINT64_BE
#define GET_UINT64_BE(n, b, i)                                              \
  {                                                                         \
    (n) = ((uint64_t)(b)[(i)] << 56) | ((uint64_t)(b)[(i) + 1] << 48) |     \
          ((uint64_t)(b)[(i) + 2] << 40) | ((uint64_t)(b)[(i) + 3] << 32) | \
          ((uint64_t)(b)[(i) + 4] << 24) | ((uint64_t)(b)[(i) + 5] << 16) | \
          ((uint64_t)(b)[(i) + 6] << 8) | ((uint64_t)(b)[(i) + 7]);         \
  }
#endif /* GET_UINT64_BE */

#ifndef PUT_UINT64_BE
#define PUT_UINT64_BE(n, b, i)                 \
  {                                            \
    (b)[(i)] = (unsigned char)((n) >> 56);     \
    (b)[(i) + 1] = (unsigned char)((n) >> 48); \
    (b)[(i) + 2] = (unsigned char)((n) >> 40); \
    (b)[(i) + 3] = (unsigned char)((n) >> 32); \
    (b)[(i) + 4] = (unsigned char)((n) >> 24); \
    (b)[(i) + 5] = (unsigned char)((n) >> 16); \
    (b)[(i) + 6] = (unsigned char)((n) >> 8);  \
    (b)[(i) + 7] = (unsigned char)((n));       \
  }
#endif /* PUT_UINT64_BE */

static void mbedtls_sha512_init(mbedtls_sha512_context *ctx) {
  memset(ctx, 0, sizeof(mbedtls_sha512_context));
}

/*
 * SHA-512 context setup
 */
static void mbedtls_sha512_starts(mbedtls_sha512_context *ctx) {
  ctx->total[0] = 0;
  ctx->total[1] = 0;

  ctx->state[0] = UL64(0x6A09E667F3BCC908);
  ctx->state[1] = UL64(0xBB67AE8584CAA73B);
  ctx->state[2] = UL64(0x3C6EF372FE94F82B);
  ctx->state[3] = UL64(0xA54FF53A5F1D36F1);
  ctx->state[4] = UL64(0x510E527FADE682D1);
  ctx->state[5] = UL64(0x9B05688C2B3E6C1F);
  ctx->state[6] = UL64(0x1F83D9ABFB41BD6B);
  ctx->state[7] = UL64(0x5BE0CD19137E2179);
}

/*
 * Round constants
 */
static const uint64_t K[80] = {
    UL64(0x428A2F98D728AE22), UL64(0x7137449123EF65CD),
    UL64(0xB5C0FBCFEC4D3B2F), UL64(0xE9B5DBA58189DBBC),
    UL64(0x3956C25BF348B538), UL64(0x59F111F1B605D019),
    UL64(0x923F82A4AF194F9B), UL64(0xAB1C5ED5DA6D8118),
    UL64(0xD807AA98A3030242), UL64(0x12835B0145706FBE),
    UL64(0x243185BE4EE4B28C), UL64(0x550C7DC3D5FFB4E2),
    UL64(0x72BE5D74F27B896F), UL64(0x80DEB1FE3B1696B1),
    UL64(0x9BDC06A725C71235), UL64(0xC19BF174CF692694),
    UL64(0xE49B69C19EF14AD2), UL64(0xEFBE4786384F25E3),
    UL64(0x0FC19DC68B8CD5B5), UL64(0x240CA1CC77AC9C65),
    UL64(0x2DE92C6F592B0275), UL64(0x4A7484AA6EA6E483),
    UL64(0x5CB0A9DCBD41FBD4), UL64(0x76F988DA831153B5),
    UL64(0x983E5152EE66DFAB), UL64(0xA831C66D2DB43210),
    UL64(0xB00327C898FB213F), UL64(0xBF597FC7BEEF0EE4),
    UL64(0xC6E00BF33DA88FC2), UL64(0xD5A79147930AA725),
    UL64(0x06CA6351E003826F), UL64(0x142929670A0E6E70),
    UL64(0x27B70A8546D22FFC), UL64(0x2E1B21385C26C926),
    UL64(0x4D2C6DFC5AC42AED), UL64(0x53380D139D95B3DF),
    UL64(0x650A73548BAF63DE), UL64(0x766A0ABB3C77B2A8),
    UL64(0x81C2C92E47EDAEE6), UL64(0x92722C851482353B),
    UL64(0xA2BFE8A14CF10364), UL64(0xA81A664BBC423001),
    UL64(0xC24B8B70D0F89791), UL64(0xC76C51A30654BE30),
    UL64(0xD192E819D6EF5218), UL64(0xD69906245565A910),
    UL64(0xF40E35855771202A), UL64(0x106AA07032BBD1B8),
    UL64(0x19A4C116B8D2D0C8), UL64(0x1E376C085141AB53),
    UL64(0x2748774CDF8EEB99), UL64(0x34B0BCB5E19B48A8),
    UL64(0x391C0CB3C5C95A63), UL64(0x4ED8AA4AE3418ACB),
    UL64(0x5B9CCA4F7763E373), UL64(0x682E6FF3D6B2B8A3),
    UL64(0x748F82EE5DEFB2FC), UL64(0x78A5636F43172F60),
    UL64(0x84C87814A1F0AB72), UL64(0x8CC702081A6439EC),
    UL64(0x90BEFFFA23631E28), UL64(0xA4506CEBDE82BDE9),
    UL64(0xBEF9A3F7B2C67915), UL64(0xC67178F2E372532B),
    UL64(0xCA273ECEEA26619C), UL64(0xD186B8C721C0C207),
    UL64(0xEADA7DD6CDE0EB1E), UL64(0xF57D4F7FEE6ED178),
    UL64(0x06F067AA72176FBA), UL64(0x0A637DC5A2C898A6),
    UL64(0x113F9804BEF90DAE), UL64(0x1B710B35131C471B),
    UL64(0x28DB77F523047D84), UL64(0x32CAAB7B40C72493),
    UL64(0x3C9EBE0A15C9BEBC), UL64(0x431D67C49C100D4C),
    UL64(0x4CC5D4BECB3E42B6), UL64(0x597F299CFC657E2A),
    UL64(0x5FCB6FAB3AD6FAEC), UL64(0x6C44198C4A475817)};

static void mbedtls_sha512_process(mbedtls_sha512_context *ctx,
                                   const unsigned char data[128]) {
  int i;
  uint64_t temp1, temp2, W[80];
  uint64_t A, B, C, D, E, F, G, H;

#define SHR(x, n) (x >> n)
#define ROTR(x, n) (SHR(x, n) | (x << (64 - n)))

#define S0(x) (ROTR(x, 1) ^ ROTR(x, 8) ^ SHR(x, 7))
#define S1(x) (ROTR(x, 19) ^ ROTR(x, 61) ^ SHR(x, 6))

#define S2(x) (ROTR(x, 28) ^ ROTR(x, 34) ^ ROTR(x, 39))
#define S3(x) (ROTR(x, 14) ^ ROTR(x, 18) ^ ROTR(x, 41))

#define F0(x, y, z) ((x & y) | (z & (x | y)))
#define F1(x, y, z) (z ^ (x & (y ^ z)))

#define P(a, b, c, d, e, f, g, h, x, K)      \
  {                                          \
    temp1 = h + S3(e) + F1(e, f, g) + K + x; \
    temp2 = S2(a) + F0(a, b, c);             \
    d += temp1;                              \
    h = temp1 + temp2;                       \
  }

  for (i = 0; i < 16; i++) {
    GET_UINT64_BE(W[i], data, i << 3);
  }

  for (; i < 80; i++) {
    W[i] = S1(W[i - 2]) + W[i - 7] + S0(W[i - 15]) + W[i - 16];
  }

  A = ctx->state[0];
  B = ctx->state[1];
  C = ctx->state[2];
  D = ctx->state[3];
  E = ctx->state[4];
  F = ctx->state[5];
  G = ctx->state[6];
  H = ctx->state[7];
  i = 0;

  do {
    P(A, B, C, D, E, F, G, H, W[i], K[i]);
    i++;
    P(H, A, B, C, D, E, F, G, W[i], K[i]);
    i++;
    P(G, H, A, B, C, D, E, F, W[i], K[i]);
    i++;
    P(F, G, H, A, B, C, D, E, W[i], K[i]);
    i++;
    P(E, F, G, H, A, B, C, D, W[i], K[i]);
    i++;
    P(D, E, F, G, H, A, B, C, W[i], K[i]);
    i++;
    P(C, D, E, F, G, H, A, B, W[i], K[i]);
    i++;
    P(B, C, D, E, F, G, H, A, W[i], K[i]);
    i++;
  } while (i < 80);

  ctx->state[0] += A;
  ctx->state[1] += B;
  ctx->state[2] += C;
  ctx->state[3] += D;
  ctx->state[4] += E;
  ctx->state[5] += F;
  ctx->state[6] += G;
  ctx->state[7] += H;
}

/*
 * SHA-512 process buffer
 */
static void mbedtls_sha512_update(mbedtls_sha512_context *ctx,
                                  const unsigned char *input, size_t ilen) {
  size_t fill;
  unsigned int left;

  if (ilen == 0) return;

  left = (unsigned int)(ctx->total[0] & 0x7F);
  fill = 128 - left;

  ctx->total[0] += (uint64_t)ilen;

  if (ctx->total[0] < (uint64_t)ilen) ctx->total[1]++;

  if (left && ilen >= fill) {
    memcpy((void *)(ctx->buffer + left), input, fill);
    mbedtls_sha512_process(ctx, ctx->buffer);
    input += fill;
    ilen -= fill;
    left = 0;
  }

  while (ilen >= 128) {
    mbedtls_sha512_process(ctx, input);
    input += 128;
    ilen -= 128;
  }

  if (ilen > 0) memcpy((void *)(ctx->buffer + left), input, ilen);
}

static const unsigned char sha512_padding[128] = {
    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

/*
 * SHA-512 final digest
 */
static void mbedtls_sha512_finish(mbedtls_sha512_context *ctx,
                                  unsigned char output[64]) {
  size_t last, padn;
  uint64_t high, low;
  unsigned char msglen[16];

  high = (ctx->total[0] >> 61) | (ctx->total[1] << 3);
  low = (ctx->total[0] << 3);

  PUT_UINT64_BE(high, msglen, 0);
  PUT_UINT64_BE(low, msglen, 8);

  last = (size_t)(ctx->total[0] & 0x7F);
  padn = (last < 112) ? (112 - last) : (240 - last);

  mbedtls_sha512_update(ctx, sha512_padding, padn);
  mbedtls_sha512_update(ctx, msglen, 16);

  PUT_UINT64_BE(ctx->state[0], output, 0);
  PUT_UINT64_BE(ctx->state[1], output, 8);
  PUT_UINT64_BE(ctx->state[2], output, 16);
  PUT_UINT64_BE(ctx->state[3], output, 24);
  PUT_UINT64_BE(ctx->state[4], output, 32);
  PUT_UINT64_BE(ctx->state[5], output, 40);
  PUT_UINT64_BE(ctx->state[6], output, 48);
  PUT_UINT64_BE(ctx->state[7], output, 56);
}

/*
 * output = SHA-512( input buffer )
 */
void SHA512(const uint8_t *in, size_t n, uint8_t out[SHA512_DIGEST_LENGTH]) {
  mbedtls_sha512_context ctx;

  mbedtls_sha512_init(&ctx);
  mbedtls_sha512_starts(&ctx);
  mbedtls_sha512_update(&ctx, in, n);
  mbedtls_sha512_finish(&ctx, out);
  secure_wipe((uint8_t *)&ctx, sizeof(ctx));
}

uint8_t antifuzz_hash_cmp(uint8_t hash1[SHA512_DIGEST_LENGTH], uint8_t hash2[SHA512_DIGEST_LENGTH]);
uint8_t antifuzz_str_equal(char* variableStr, uint8_t constHash[SHA512_DIGEST_LENGTH]);
uint8_t antifuzz_equal(uint8_t *in, size_t size, uint8_t constHash[SHA512_DIGEST_LENGTH]);
uint8_t antifuzz_char_equal(char value, uint8_t constHash[SHA512_DIGEST_LENGTH]);
uint8_t antifuzz_int_equal(int value, uint8_t constHash[SHA512_DIGEST_LENGTH]);
uint8_t antifuzz_long_equal(long value, uint8_t constHash[SHA512_DIGEST_LENGTH]);
uint8_t antifuzz_long_long_equal(long long value, uint8_t constHash[SHA512_DIGEST_LENGTH]);
#endif
void antifuzz_onerror();
void antifuzz_init(char* filePath, unsigned int flags);
char *antifuzz_init_multiple(char *filePathOrBuffer, unsigned int flags);
void antifuzz_exit(unsigned int flags);
char* _antifuzz_init(char *filePathOrBuffer, int size, unsigned int flags);
#if FOR_CGC
void antifuzz_init_cgc(char **buffer, int size, unsigned int flags);
#else
size_t antifuzz_fread(void * ptr, size_t size, size_t count, FILE * stream);
/*int antifuzz_fclose(FILE *stream);
FILE *antifuzz_fopen(const char *filename, const char *mode);
void antifuzz_generate_queue_file_by_filename(char* inputfilename);*/
#endif
void antifuzz_encrypt_decrypt_buf(char *ptr, size_t fileSize) ;

/* antifuzz_constants.tpl.h */
#if USE_HASH_CMP
#ifndef antifuzz_CONSTANTS_H
#define antifuzz_CONSTANTS_H
/*
* Do not remove this comment.
* Edit content AFTER this comment.
* @START */

static uint8_t antifuzzChar[SHA512_DIGEST_LENGTH] = {0x1f, 0x40, 0xfc, 0x92, 0xda, 0x24, 0x16, 0x94, 0x75, 0x09, 0x79, 0xee, 0x6c, 0xf5, 0x82, 0xf2, 0xd5, 0xd7, 0xd2, 0x8e, 0x18, 0x33, 0x5d, 0xe0, 0x5a, 0xbc, 0x54, 0xd0, 0x56, 0x0e, 0x0f, 0x53, 0x02, 0x86, 0x0c, 0x65, 0x2b, 0xf0, 0x8d, 0x56, 0x02, 0x52, 0xaa, 0x5e, 0x74, 0x21, 0x05, 0x46, 0xf3, 0x69, 0xfb, 0xbb, 0xce, 0x8c, 0x12, 0xcf, 0xc7, 0x95, 0x7b, 0x26, 0x52, 0xfe, 0x9a, 0x75};
static uint8_t antifuzz0x12345678[SHA512_DIGEST_LENGTH] = {0x71, 0xb4, 0xaa, 0xaa, 0x8e, 0xbb, 0x18, 0x3e, 0x01, 0xdf, 0xeb, 0x60, 0xfe, 0xf7, 0x66, 0x53, 0x2f, 0xb0, 0x60, 0xc9, 0x17, 0x03, 0xce, 0xca, 0x23, 0x85, 0x3b, 0x25, 0x70, 0x77, 0x61, 0xba, 0x9a, 0xdb, 0xdd, 0x52, 0x79, 0xc2, 0x56, 0xb0, 0x0a, 0xf7, 0x97, 0xfc, 0xf6, 0xed, 0x69, 0x53, 0xd0, 0x72, 0x78, 0xb6, 0x2d, 0x5e, 0xc4, 0xbc, 0xf1, 0x66, 0x00, 0x4a, 0x6d, 0xf8, 0x7a, 0xa0};
static uint8_t antifuzz0x1122334455667788[SHA512_DIGEST_LENGTH] = {0x02, 0x19, 0x9a, 0x71, 0xd7, 0x2c, 0x35, 0xba, 0x7f, 0x20, 0x34, 0x53, 0x08, 0x82, 0x85, 0x45, 0x78, 0x61, 0x1d, 0x05, 0x98, 0x03, 0xf5, 0x0f, 0xf4, 0x70, 0xbc, 0xed, 0xee, 0xde, 0xe3, 0x30, 0xbc, 0xaa, 0x22, 0xf9, 0xff, 0x42, 0x5a, 0xb1, 0x13, 0xdf, 0xcd, 0x84, 0xae, 0x1d, 0x9c, 0x29, 0x57, 0x8f, 0x07, 0x12, 0xe8, 0xc2, 0xbe, 0x87, 0xab, 0xfe, 0xa9, 0xfb, 0x28, 0x05, 0x6d, 0xff};
static uint8_t antifuzzHello[SHA512_DIGEST_LENGTH] = {0x9b, 0x71, 0xd2, 0x24, 0xbd, 0x62, 0xf3, 0x78, 0x5d, 0x96, 0xd4, 0x6a, 0xd3, 0xea, 0x3d, 0x73, 0x31, 0x9b, 0xfb, 0xc2, 0x89, 0x0c, 0xaa, 0xda, 0xe2, 0xdf, 0xf7, 0x25, 0x19, 0x67, 0x3c, 0xa7, 0x23, 0x23, 0xc3, 0xd9, 0x9b, 0xa5, 0xc1, 0x1d, 0x7c, 0x7a, 0xcc, 0x6e, 0x14, 0xb8, 0xc5, 0xda, 0x0c, 0x46, 0x63, 0x47, 0x5c, 0x2e, 0x5c, 0x3a, 0xde, 0xf4, 0x6f, 0x73, 0xbc, 0xde, 0xc0, 0x43};

static uint8_t antifuzzC[SHA512_DIGEST_LENGTH] = {0xac, 0xc2, 0x8d, 0xb2, 0xbe, 0xb7, 0xb4, 0x2b, 0xaa, 0x1c, 0xb0, 0x24, 0x3d, 0x40, 0x1c, 0xcb, 0x4e, 0x3f, 0xce, 0x44, 0xd7, 0xb0, 0x28, 0x79, 0xa5, 0x27, 0x99, 0xaa, 0xdf, 0xf5, 0x41, 0x52, 0x2d, 0x88, 0x22, 0x59, 0x8b, 0x2f, 0xa6, 0x64, 0xf9, 0xd5, 0x15, 0x6c, 0x00, 0xc9, 0x24, 0x80, 0x5d, 0x75, 0xc3, 0x86, 0x8b, 0xd5, 0x6c, 0x2a, 0xcb, 0x81, 0xd3, 0x7e, 0x98, 0xe3, 0x5a, 0xdc};
static uint8_t antifuzzR[SHA512_DIGEST_LENGTH] = {0xa8, 0x82, 0xf0, 0xac, 0x84, 0x8b, 0x0b, 0x6b, 0x4c, 0xa7, 0xb4, 0x2b, 0xfa, 0x1d, 0x26, 0x6a, 0xfd, 0x0d, 0xde, 0xba, 0x92, 0x04, 0xae, 0x57, 0xa9, 0x84, 0xa6, 0x93, 0x76, 0xd5, 0x98, 0x16, 0xb1, 0xef, 0x3f, 0x4d, 0x44, 0x2e, 0xa8, 0xa7, 0x03, 0x96, 0x06, 0x7f, 0xf5, 0xb7, 0x0e, 0x0a, 0xe8, 0xea, 0xb3, 0x93, 0x5b, 0x61, 0x7b, 0x8e, 0x36, 0x6d, 0x8e, 0x35, 0xc3, 0xbf, 0xe1, 0x4c};
static uint8_t antifuzzS[SHA512_DIGEST_LENGTH] = {0x2c, 0x1e, 0xe6, 0x83, 0x72, 0x21, 0x5b, 0x1c, 0xe0, 0x64, 0x42, 0x6b, 0x5c, 0xdb, 0xd4, 0xef, 0x25, 0x81, 0xac, 0xe0, 0xdd, 0x3b, 0x21, 0xfa, 0x2b, 0xe2, 0x7f, 0x36, 0x48, 0x27, 0x24, 0x2e, 0x83, 0xf6, 0x8b, 0x68, 0xbe, 0x03, 0xf5, 0xb3, 0xe2, 0x4b, 0xe5, 0xd1, 0xb4, 0x31, 0x5f, 0x98, 0xa0, 0xa9, 0x6d, 0x19, 0x71, 0x3f, 0xb3, 0xa1, 0x9d, 0xc4, 0x55, 0xfb, 0x6a, 0xdc, 0x34, 0x31};
static uint8_t antifuzzH[SHA512_DIGEST_LENGTH] = {0x22, 0x41, 0xbc, 0x8f, 0xc7, 0x07, 0x05, 0xb4, 0x2e, 0xfe, 0xad, 0x37, 0x1f, 0xd4, 0x98, 0x2c, 0x5b, 0xa6, 0x99, 0x17, 0xe5, 0xb4, 0xb8, 0x95, 0x81, 0x00, 0x02, 0x64, 0x4f, 0x03, 0x86, 0xda, 0x9c, 0x31, 0x31, 0x79, 0x34, 0x58, 0xc2, 0xbf, 0x47, 0x60, 0x84, 0x80, 0xd6, 0x4a, 0x07, 0x27, 0x81, 0x33, 0xc9, 0x99, 0x12, 0xe0, 0xba, 0x2d, 0xaf, 0x23, 0x09, 0x8f, 0x35, 0x20, 0xeb, 0x97};
static uint8_t antifuzzEqual[SHA512_DIGEST_LENGTH] = {0x4f, 0x6a, 0xbf, 0x29, 0xbc, 0x73, 0x7b, 0x74, 0x17, 0x05, 0xd9, 0xb6, 0xe7, 0x92, 0xf0, 0x55, 0xbf, 0x13, 0x84, 0xf3, 0x64, 0x09, 0x95, 0x97, 0x40, 0xd8, 0x3e, 0x4f, 0x3b, 0xd7, 0x75, 0x08, 0x4e, 0xdc, 0x65, 0x6b, 0xb4, 0x8b, 0x5d, 0x29, 0x42, 0x51, 0x8a, 0xf2, 0x89, 0x43, 0x32, 0x12, 0x61, 0x3f, 0xa3, 0xa3, 0x01, 0x77, 0x83, 0xe1, 0xca, 0xb3, 0xbd, 0xfd, 0x89, 0x62, 0x36, 0x63};
static uint8_t antifuzzNewline[SHA512_DIGEST_LENGTH] = {0xbe, 0x68, 0x88, 0x38, 0xca, 0x86, 0x86, 0xe5, 0xc9, 0x06, 0x89, 0xbf, 0x2a, 0xb5, 0x85, 0xce, 0xf1, 0x13, 0x7c, 0x99, 0x9b, 0x48, 0xc7, 0x0b, 0x92, 0xf6, 0x7a, 0x5c, 0x34, 0xdc, 0x15, 0x69, 0x7b, 0x5d, 0x11, 0xc9, 0x82, 0xed, 0x6d, 0x71, 0xbe, 0x1e, 0x1e, 0x7f, 0x7b, 0x4e, 0x07, 0x33, 0x88, 0x4a, 0xa9, 0x7c, 0x3f, 0x7a, 0x33, 0x9a, 0x8e, 0xd0, 0x35, 0x77, 0xcf, 0x74, 0xbe, 0x09};

static uint8_t antifuzzBigA[SHA512_DIGEST_LENGTH] = {0x21, 0xb4, 0xf4, 0xbd, 0x9e, 0x64, 0xed, 0x35, 0x5c, 0x3e, 0xb6, 0x76, 0xa2, 0x8e, 0xbe, 0xda, 0xf6, 0xd8, 0xf1, 0x7b, 0xdc, 0x36, 0x59, 0x95, 0xb3, 0x19, 0x09, 0x71, 0x53, 0x04, 0x40, 0x80, 0x51, 0x6b, 0xd0, 0x83, 0xbf, 0xcc, 0xe6, 0x61, 0x21, 0xa3, 0x07, 0x26, 0x46, 0x99, 0x4c, 0x84, 0x30, 0xcc, 0x38, 0x2b, 0x8d, 0xc5, 0x43, 0xe8, 0x48, 0x80, 0x18, 0x3b, 0xf8, 0x56, 0xcf, 0xf5};
static uint8_t antifuzzBigB[SHA512_DIGEST_LENGTH] = {0x84, 0x8b, 0x07, 0x79, 0xff, 0x41, 0x5f, 0x0a, 0xf4, 0xea, 0x14, 0xdf, 0x9d, 0xd1, 0xd3, 0xc2, 0x9a, 0xc4, 0x1d, 0x83, 0x6c, 0x78, 0x08, 0x89, 0x6c, 0x4e, 0xba, 0x19, 0xc5, 0x1a, 0xc4, 0x0a, 0x43, 0x9c, 0xaf, 0x5e, 0x61, 0xec, 0x88, 0xc3, 0x07, 0xc7, 0xd6, 0x19, 0x19, 0x52, 0x29, 0x41, 0x2e, 0xaa, 0x73, 0xfb, 0x2a, 0x5e, 0xa2, 0x0d, 0x23, 0xcc, 0x86, 0xa9, 0xd8, 0xf8, 0x6a, 0x0f};
static uint8_t antifuzzBigC[SHA512_DIGEST_LENGTH] = {0x3d, 0x63, 0x7a, 0xe6, 0x3d, 0x59, 0x52, 0x2d, 0xd3, 0xcb, 0x1b, 0x81, 0xc1, 0xad, 0x67, 0xe5, 0x6d, 0x46, 0x18, 0x5b, 0x09, 0x71, 0xe0, 0xbc, 0x7d, 0xd2, 0xd8, 0xad, 0x3b, 0x26, 0x09, 0x0a, 0xcb, 0x63, 0x4c, 0x25, 0x2f, 0xc6, 0xa6, 0x3b, 0x37, 0x66, 0x93, 0x43, 0x14, 0xea, 0x1a, 0x6e, 0x59, 0xfa, 0x0c, 0x8c, 0x2b, 0xc0, 0x27, 0xa7, 0xb6, 0xa4, 0x60, 0xb2, 0x91, 0xcd, 0x4d, 0xfb};
static uint8_t antifuzzBigD[SHA512_DIGEST_LENGTH] = {0x2a, 0xc9, 0x68, 0x75, 0x2f, 0x62, 0x4b, 0xe3, 0xe3, 0xdf, 0x46, 0x76, 0x4b, 0x51, 0xb7, 0x83, 0x1f, 0xeb, 0x70, 0xd4, 0x03, 0x07, 0xdf, 0x5d, 0x58, 0x7d, 0x47, 0x93, 0xbf, 0xfe, 0xaf, 0x8b, 0x40, 0x42, 0xa1, 0xfd, 0x6d, 0x46, 0x5d, 0xf2, 0xaa, 0xcc, 0x33, 0x04, 0x32, 0x8d, 0x43, 0x1e, 0xf1, 0x0e, 0x08, 0x3b, 0xaf, 0x69, 0x0b, 0x8c, 0xc5, 0x35, 0x48, 0x0a, 0x4f, 0xef, 0x09, 0x2f};
static uint8_t antifuzzBigE[SHA512_DIGEST_LENGTH] = {0x99, 0xc4, 0x26, 0xcc, 0x0b, 0xf3, 0xc4, 0x65, 0xf9, 0xc4, 0xa4, 0x9e, 0x5a, 0x6c, 0x3d, 0x09, 0xa4, 0x3c, 0x4f, 0x95, 0x63, 0x17, 0x76, 0xb3, 0x54, 0xbe, 0x07, 0x27, 0xf3, 0xf6, 0x55, 0x67, 0xae, 0x93, 0x57, 0xc5, 0xd5, 0x50, 0x15, 0xe2, 0xcf, 0xbb, 0x27, 0xea, 0xd9, 0x8e, 0x1b, 0xb5, 0x4f, 0x2a, 0x0f, 0x26, 0x04, 0x2a, 0xd2, 0x67, 0xa2, 0x79, 0xf0, 0xe3, 0xa8, 0xc5, 0xb2, 0xe9};
static uint8_t antifuzzBigF[SHA512_DIGEST_LENGTH] = {0xd2, 0x1e, 0xc9, 0x14, 0x6c, 0x3c, 0x32, 0x72, 0x11, 0xb8, 0xb7, 0xfd, 0x44, 0x00, 0x39, 0x16, 0xb9, 0x38, 0xd7, 0x51, 0xd4, 0x58, 0xfe, 0xce, 0x25, 0xef, 0x51, 0xfa, 0x9c, 0x88, 0x96, 0xc9, 0x7c, 0xeb, 0x22, 0xd0, 0x32, 0xe6, 0xdc, 0x73, 0x88, 0xc6, 0x14, 0x3a, 0x3b, 0x31, 0x57, 0x76, 0x49, 0x49, 0xa7, 0xb2, 0xcb, 0xb0, 0x62, 0xe0, 0x05, 0xdd, 0x5f, 0x00, 0x93, 0x10, 0xab, 0x00};
static uint8_t antifuzzBigG[SHA512_DIGEST_LENGTH] = {0xda, 0x63, 0x7b, 0x3f, 0x32, 0xd7, 0xc7, 0xe4, 0x10, 0xab, 0x61, 0x95, 0x20, 0xe0, 0xcf, 0x45, 0x29, 0x16, 0x9a, 0x5c, 0x32, 0x6e, 0xcb, 0xf4, 0xca, 0x7a, 0x3b, 0xc2, 0x33, 0x0a, 0xd4, 0x9a, 0x84, 0xfb, 0xa4, 0xd6, 0xc8, 0x91, 0x92, 0x64, 0xee, 0xc5, 0xdc, 0x75, 0xef, 0x80, 0x13, 0x7f, 0x78, 0xcd, 0xa4, 0x0e, 0x26, 0xf3, 0xf7, 0x41, 0xb5, 0xc9, 0xff, 0x25, 0x9d, 0x6e, 0xfd, 0xbf};
static uint8_t antifuzzBigH[SHA512_DIGEST_LENGTH] = {0x90, 0x32, 0xfb, 0x94, 0x05, 0x5d, 0x4d, 0x14, 0xe4, 0x21, 0x85, 0xbd, 0xff, 0x59, 0x64, 0x2b, 0x98, 0xfe, 0x60, 0x73, 0xf6, 0x8f, 0x29, 0xd3, 0x94, 0x62, 0x0c, 0x4e, 0x69, 0x8a, 0x86, 0xfb, 0x2e, 0x51, 0x35, 0x1c, 0xa6, 0x99, 0x7e, 0x6a, 0x16, 0x4a, 0xae, 0x0b, 0x87, 0x1c, 0xf7, 0x89, 0xfb, 0xc6, 0xe0, 0xd8, 0x63, 0x73, 0x3d, 0x05, 0x90, 0x3b, 0x4e, 0xb1, 0x1b, 0xe5, 0x8d, 0x9c};
static uint8_t antifuzzBigI[SHA512_DIGEST_LENGTH] = {0x32, 0xb1, 0x78, 0x6e, 0xca, 0x2b, 0x9f, 0x81, 0x5b, 0x4c, 0x52, 0xb9, 0x99, 0xe2, 0xb3, 0x4d, 0xae, 0x87, 0x7a, 0x86, 0xc0, 0x0e, 0x8f, 0x74, 0x5e, 0x7a, 0xc2, 0x33, 0x88, 0x66, 0x5c, 0x07, 0x03, 0xa9, 0x47, 0x08, 0x5b, 0xd7, 0xf9, 0x75, 0xc5, 0x21, 0x0f, 0xfa, 0xb9, 0xb5, 0xa8, 0xf3, 0x93, 0x1a, 0xb4, 0x0b, 0x26, 0xcd, 0x7b, 0xcc, 0xc4, 0xd7, 0x69, 0x0c, 0xd1, 0x9a, 0x42, 0x77};
static uint8_t antifuzzBigJ[SHA512_DIGEST_LENGTH] = {0x3c, 0x26, 0x6c, 0x00, 0x35, 0xde, 0x59, 0xea, 0xb2, 0xa0, 0xdd, 0x31, 0xb3, 0xdc, 0xb4, 0xa9, 0xdd, 0x15, 0x7b, 0x31, 0x02, 0x89, 0xe5, 0xdb, 0x9a, 0xb4, 0xf8, 0xc2, 0xfd, 0xdb, 0x74, 0x33, 0x46, 0x6d, 0x48, 0xf2, 0x5d, 0xa7, 0xad, 0x73, 0x5a, 0x1c, 0xb8, 0xf2, 0x93, 0x5a, 0xa6, 0x12, 0xad, 0x1f, 0x62, 0xf0, 0xef, 0xce, 0xce, 0x39, 0x33, 0xba, 0x99, 0x79, 0x08, 0x2e, 0x23, 0x04};
static uint8_t antifuzzBigK[SHA512_DIGEST_LENGTH] = {0xdd, 0xdb, 0x9e, 0xc4, 0xc4, 0xac, 0x04, 0xa2, 0x55, 0x9d, 0x9b, 0x71, 0x1e, 0xaa, 0x8e, 0x35, 0x47, 0x5d, 0xb3, 0xc4, 0xd6, 0xa7, 0xa0, 0x6d, 0xde, 0x78, 0x5d, 0xc8, 0x3f, 0x3e, 0xd1, 0x21, 0x71, 0x0c, 0xb5, 0x12, 0x73, 0x3c, 0x80, 0x95, 0xff, 0x34, 0x6f, 0xc8, 0x60, 0x1e, 0x7a, 0x73, 0xec, 0xb5, 0x3f, 0xac, 0x75, 0x20, 0x10, 0x11, 0x6e, 0x69, 0x2b, 0x1c, 0xe7, 0x3c, 0x8e, 0x59};
static uint8_t antifuzzBigL[SHA512_DIGEST_LENGTH] = {0x24, 0x2d, 0xcc, 0xbd, 0x15, 0xe4, 0x0f, 0x8f, 0x78, 0xcb, 0x6f, 0xc5, 0x4c, 0xb9, 0x89, 0x47, 0x13, 0xb7, 0x68, 0x2a, 0xfd, 0x13, 0x05, 0xd5, 0x23, 0x0e, 0x26, 0xf2, 0xfd, 0xa9, 0x6f, 0xd7, 0x64, 0x06, 0x17, 0x13, 0xe4, 0x95, 0x4e, 0x22, 0x45, 0x7b, 0x37, 0xf2, 0x5c, 0x32, 0x8e, 0x83, 0x42, 0xc2, 0xbf, 0x6b, 0x55, 0x84, 0x46, 0x10, 0xcd, 0x07, 0x56, 0xfd, 0x02, 0x27, 0x1a, 0xef};
static uint8_t antifuzzBigM[SHA512_DIGEST_LENGTH] = {0x25, 0x34, 0x05, 0xe0, 0x3b, 0x91, 0x44, 0x1a, 0x6d, 0xd3, 0x54, 0xa9, 0xb7, 0x2e, 0x04, 0x00, 0x68, 0xb1, 0xbf, 0xe1, 0x0e, 0x83, 0xeb, 0x1a, 0x64, 0xa0, 0x86, 0xc0, 0x55, 0x25, 0xd8, 0xcc, 0xae, 0x2b, 0xf0, 0x91, 0x30, 0xc6, 0x24, 0xaf, 0x50, 0xd5, 0x5c, 0x35, 0x22, 0xa4, 0xfb, 0xb7, 0xc1, 0x8c, 0xfc, 0x8d, 0xd8, 0x43, 0xe5, 0xf4, 0x80, 0x1d, 0x9a, 0xd2, 0xb5, 0x16, 0x4b, 0x12};
static uint8_t antifuzzBigN[SHA512_DIGEST_LENGTH] = {0x6b, 0x3b, 0x00, 0x6a, 0xa3, 0xa8, 0x62, 0x86, 0xc3, 0x59, 0xa6, 0xd2, 0x43, 0xd6, 0x2a, 0x61, 0xe4, 0x6f, 0x0c, 0x5f, 0x7d, 0x1d, 0xb5, 0x87, 0xfa, 0xa2, 0x6f, 0xbe, 0x72, 0x71, 0x8e, 0xae, 0xe3, 0x3f, 0x77, 0x4a, 0xf1, 0x64, 0xe3, 0xba, 0x79, 0x0d, 0x4a, 0xe4, 0x13, 0x6a, 0x25, 0xdc, 0x99, 0x3d, 0x32, 0x46, 0xf7, 0xbe, 0x66, 0x91, 0xfa, 0x73, 0x46, 0xd0, 0xbe, 0x0f, 0x1a, 0x71};
static uint8_t antifuzzBigO[SHA512_DIGEST_LENGTH] = {0x78, 0x05, 0x56, 0xc0, 0x4b, 0x27, 0x14, 0xff, 0x1d, 0x7e, 0xce, 0xdc, 0x57, 0x32, 0x60, 0xfa, 0xf1, 0x69, 0xd0, 0x59, 0x87, 0x1c, 0xb3, 0x15, 0x41, 0x53, 0xf9, 0xc0, 0x06, 0x36, 0x24, 0x2d, 0x83, 0xbd, 0x55, 0x5a, 0xd0, 0xd7, 0x23, 0xae, 0x7c, 0x0b, 0x7b, 0x63, 0x97, 0x85, 0x05, 0x77, 0xf7, 0x0d, 0x5c, 0x5f, 0xaf, 0xd5, 0x15, 0x5d, 0x7d, 0x27, 0xb6, 0x66, 0x3c, 0x9b, 0xb5, 0x76};
static uint8_t antifuzzBigP[SHA512_DIGEST_LENGTH] = {0xeb, 0xec, 0xf2, 0x7f, 0x9d, 0x01, 0xa3, 0x1e, 0x1b, 0x7f, 0xde, 0x7d, 0x28, 0xbe, 0xfe, 0x99, 0x24, 0x91, 0xca, 0x56, 0x78, 0xe5, 0xc1, 0xfa, 0xf5, 0x9d, 0x68, 0x81, 0x71, 0xff, 0x0d, 0xc1, 0x20, 0xe7, 0x5c, 0x88, 0x82, 0x13, 0xce, 0x34, 0x0c, 0xf8, 0xd3, 0xba, 0xe4, 0xc4, 0x31, 0xfb, 0xfb, 0x69, 0x92, 0x71, 0x9a, 0x43, 0x72, 0xb5, 0x1b, 0x9d, 0xd8, 0x8b, 0x81, 0x54, 0x7f, 0x01};
static uint8_t antifuzzBigQ[SHA512_DIGEST_LENGTH] = {0x2d, 0xdc, 0xd5, 0xfd, 0x66, 0xf6, 0x2c, 0x38, 0x13, 0x56, 0x03, 0xde, 0xfc, 0x72, 0x84, 0x93, 0xbc, 0x90, 0x12, 0xc9, 0xea, 0x6a, 0xbc, 0x8a, 0x98, 0x23, 0x16, 0x57, 0x92, 0x13, 0x65, 0x13, 0xb2, 0xc5, 0x37, 0x22, 0xd2, 0xa7, 0x9c, 0x0d, 0x6e, 0xa3, 0x14, 0x67, 0x30, 0x8b, 0xbb, 0x49, 0xeb, 0x21, 0x7d, 0x15, 0x1d, 0x79, 0xba, 0xf4, 0xb2, 0x08, 0x5f, 0x48, 0x7d, 0x0a, 0xbf, 0xae};
static uint8_t antifuzzBigR[SHA512_DIGEST_LENGTH] = {0xe3, 0x2a, 0xf2, 0x13, 0x45, 0xe7, 0xa9, 0x32, 0xda, 0x18, 0x6a, 0x47, 0xad, 0xb1, 0x73, 0xdd, 0x1c, 0x69, 0x98, 0x76, 0x7b, 0x25, 0xf8, 0x39, 0x7f, 0x37, 0x40, 0xe8, 0x7e, 0x59, 0x1c, 0x23, 0x70, 0xbe, 0x6f, 0x2b, 0x11, 0xc8, 0x36, 0xea, 0x6b, 0x49, 0x78, 0x03, 0x4f, 0xff, 0x23, 0x93, 0x09, 0xf7, 0x21, 0xe7, 0xbf, 0x24, 0x91, 0xb6, 0xba, 0x09, 0x9c, 0x34, 0x7f, 0xdd, 0xc2, 0x6f};
static uint8_t antifuzzBigS[SHA512_DIGEST_LENGTH] = {0x0d, 0xaa, 0x7c, 0xc9, 0x86, 0x52, 0x00, 0xb8, 0x2c, 0x0e, 0xbe, 0x57, 0x49, 0x71, 0x97, 0xa8, 0x04, 0xfd, 0xc3, 0x01, 0xef, 0x7a, 0x08, 0x8d, 0xcf, 0x0a, 0xca, 0xd7, 0xe0, 0x4a, 0x00, 0x7f, 0x52, 0xe7, 0xd0, 0xd9, 0xfc, 0x6a, 0xea, 0x38, 0x7b, 0x33, 0x3a, 0x4c, 0x72, 0xde, 0x4f, 0xbe, 0xe3, 0x87, 0x6d, 0xc4, 0x8f, 0x19, 0x69, 0x27, 0x39, 0xf7, 0xc0, 0xed, 0x4a, 0x3e, 0xdd, 0xb2};
static uint8_t antifuzzBigT[SHA512_DIGEST_LENGTH] = {0xb2, 0x39, 0x6a, 0x00, 0x2f, 0xe7, 0xae, 0xc0, 0x08, 0x80, 0x86, 0x87, 0xd7, 0xcb, 0xac, 0xb3, 0x40, 0xb7, 0xf7, 0xa0, 0x90, 0x00, 0x83, 0x82, 0xf3, 0xc9, 0x58, 0x70, 0xf6, 0xfb, 0x10, 0x41, 0x5f, 0x61, 0xf5, 0x73, 0x7c, 0x10, 0x2d, 0x4b, 0xfe, 0xc5, 0x8f, 0xe5, 0x25, 0x40, 0x7e, 0xa2, 0x00, 0x1e, 0x76, 0x1d, 0xab, 0x1d, 0xa8, 0xa5, 0x01, 0xd9, 0x52, 0x39, 0x21, 0xf0, 0xec, 0x21};
static uint8_t antifuzzBigU[SHA512_DIGEST_LENGTH] = {0xda, 0x45, 0xaf, 0xb2, 0x12, 0xb2, 0x31, 0x00, 0xf4, 0x5b, 0xd3, 0x92, 0x29, 0x3f, 0xc2, 0xf3, 0x32, 0xb0, 0xbe, 0xbc, 0x9b, 0x0c, 0xb5, 0x86, 0x6c, 0x12, 0x17, 0x43, 0xc0, 0x45, 0x80, 0x6b, 0x03, 0x17, 0x58, 0xf0, 0xb8, 0x8a, 0x72, 0x8a, 0x7b, 0x34, 0x4a, 0x8a, 0x41, 0xfe, 0x0b, 0xf0, 0x7c, 0xb3, 0x99, 0x67, 0xe0, 0x4d, 0x6b, 0x65, 0x22, 0x13, 0xfb, 0xe5, 0x13, 0xf6, 0x31, 0x7b};
static uint8_t antifuzzBigV[SHA512_DIGEST_LENGTH] = {0x40, 0x42, 0x2e, 0x27, 0x33, 0xa7, 0x3d, 0xec, 0x2f, 0x9a, 0xac, 0x48, 0xe2, 0xab, 0x48, 0xd3, 0xb2, 0xfd, 0xcd, 0xc1, 0xe3, 0xa8, 0x8b, 0xc7, 0xea, 0x85, 0x52, 0x27, 0xe6, 0x2c, 0x02, 0x92, 0x46, 0xda, 0x1d, 0xd4, 0x9d, 0xd0, 0x57, 0xbb, 0x8a, 0x8b, 0x79, 0x6b, 0x3b, 0x2a, 0x6f, 0x60, 0xd9, 0xd8, 0xa8, 0x5d, 0xe5, 0x3d, 0xf5, 0x97, 0xe4, 0x22, 0xb2, 0xf6, 0x8c, 0x54, 0xcf, 0xb6};
static uint8_t antifuzzBigW[SHA512_DIGEST_LENGTH] = {0x61, 0x03, 0x77, 0x24, 0xa2, 0xfb, 0x00, 0xa1, 0x2f, 0xa8, 0xa5, 0x3a, 0xda, 0x23, 0x3f, 0x54, 0xff, 0x7f, 0xc6, 0xee, 0x02, 0x04, 0x8e, 0x57, 0x9b, 0x83, 0xa1, 0x27, 0xce, 0x79, 0xfc, 0x03, 0x90, 0x6c, 0x35, 0xb5, 0x30, 0x7b, 0xeb, 0x18, 0xa3, 0xcf, 0x50, 0x21, 0xfe, 0x03, 0x1a, 0xe6, 0x58, 0x74, 0x48, 0xd4, 0xd6, 0x0a, 0x08, 0x2d, 0x73, 0x25, 0x2f, 0xe2, 0xe2, 0xf4, 0xae, 0x7f};
static uint8_t antifuzzBigX[SHA512_DIGEST_LENGTH] = {0x31, 0x73, 0xf0, 0x56, 0x4a, 0xb9, 0x46, 0x2b, 0x09, 0x78, 0xa7, 0x65, 0xc1, 0x28, 0x3f, 0x96, 0xf0, 0x5a, 0xc9, 0xe9, 0xf8, 0x36, 0x1e, 0xe1, 0x00, 0x6d, 0xc9, 0x05, 0xc1, 0x53, 0xd8, 0x5b, 0xf0, 0xe4, 0xc4, 0x56, 0x22, 0xe5, 0xe9, 0x90, 0xab, 0xcf, 0x48, 0xfb, 0x51, 0x92, 0xad, 0x34, 0x72, 0x2e, 0x8d, 0x6a, 0x72, 0x32, 0x78, 0xb3, 0x9f, 0xef, 0x9e, 0x4f, 0x9f, 0xc6, 0x23, 0x78};
static uint8_t antifuzzBigY[SHA512_DIGEST_LENGTH] = {0x49, 0x21, 0xde, 0x1e, 0xdb, 0x2e, 0xcc, 0x8c, 0xa3, 0xa2, 0x28, 0x23, 0x70, 0x51, 0x94, 0xb9, 0x02, 0xcf, 0xa4, 0x71, 0x67, 0x5f, 0x2d, 0x1a, 0xe8, 0xbf, 0x67, 0xd0, 0xc7, 0xb0, 0x60, 0xa7, 0xc1, 0x92, 0xe3, 0x6f, 0xfc, 0xa9, 0xf1, 0xa0, 0xd9, 0x0a, 0xc2, 0xdb, 0xbd, 0xaf, 0x42, 0x9e, 0xe1, 0xec, 0x97, 0xe1, 0x60, 0xeb, 0x00, 0xdc, 0x80, 0xb0, 0x70, 0x00, 0x93, 0x53, 0x04, 0xf3};
static uint8_t antifuzzBigZ[SHA512_DIGEST_LENGTH] = {0x32, 0x25, 0xdf, 0xf0, 0x71, 0xcd, 0x0c, 0xcf, 0xf7, 0x36, 0xb0, 0xb1, 0x59, 0xcc, 0x72, 0x29, 0x63, 0x31, 0x0c, 0x00, 0x84, 0x72, 0xbe, 0x81, 0x46, 0x69, 0x45, 0x1a, 0x06, 0x2c, 0x25, 0xc5, 0xf7, 0x65, 0x4f, 0x07, 0x9d, 0x3e, 0x0a, 0xe1, 0xcf, 0x2f, 0xda, 0x15, 0x51, 0xa5, 0xa0, 0xb1, 0xf5, 0xe9, 0x88, 0x38, 0x3b, 0xe7, 0xd3, 0x83, 0xd5, 0x7f, 0x73, 0xd4, 0x01, 0x2c, 0x40, 0x24};
static uint8_t antifuzzLittleA[SHA512_DIGEST_LENGTH] = {0x1f, 0x40, 0xfc, 0x92, 0xda, 0x24, 0x16, 0x94, 0x75, 0x09, 0x79, 0xee, 0x6c, 0xf5, 0x82, 0xf2, 0xd5, 0xd7, 0xd2, 0x8e, 0x18, 0x33, 0x5d, 0xe0, 0x5a, 0xbc, 0x54, 0xd0, 0x56, 0x0e, 0x0f, 0x53, 0x02, 0x86, 0x0c, 0x65, 0x2b, 0xf0, 0x8d, 0x56, 0x02, 0x52, 0xaa, 0x5e, 0x74, 0x21, 0x05, 0x46, 0xf3, 0x69, 0xfb, 0xbb, 0xce, 0x8c, 0x12, 0xcf, 0xc7, 0x95, 0x7b, 0x26, 0x52, 0xfe, 0x9a, 0x75};
static uint8_t antifuzzLittleB[SHA512_DIGEST_LENGTH] = {0x52, 0x67, 0x76, 0x88, 0x22, 0xee, 0x62, 0x4d, 0x48, 0xfc, 0xe1, 0x5e, 0xc5, 0xca, 0x79, 0xcb, 0xd6, 0x02, 0xcb, 0x7f, 0x4c, 0x21, 0x57, 0xa5, 0x16, 0x55, 0x69, 0x91, 0xf2, 0x2e, 0xf8, 0xc7, 0xb5, 0xef, 0x7b, 0x18, 0xd1, 0xff, 0x41, 0xc5, 0x93, 0x70, 0xef, 0xb0, 0x85, 0x86, 0x51, 0xd4, 0x4a, 0x93, 0x6c, 0x11, 0xb7, 0xb1, 0x44, 0xc4, 0x8f, 0xe0, 0x4d, 0xf3, 0xc6, 0xa3, 0xe8, 0xda};
static uint8_t antifuzzLittleC[SHA512_DIGEST_LENGTH] = {0xac, 0xc2, 0x8d, 0xb2, 0xbe, 0xb7, 0xb4, 0x2b, 0xaa, 0x1c, 0xb0, 0x24, 0x3d, 0x40, 0x1c, 0xcb, 0x4e, 0x3f, 0xce, 0x44, 0xd7, 0xb0, 0x28, 0x79, 0xa5, 0x27, 0x99, 0xaa, 0xdf, 0xf5, 0x41, 0x52, 0x2d, 0x88, 0x22, 0x59, 0x8b, 0x2f, 0xa6, 0x64, 0xf9, 0xd5, 0x15, 0x6c, 0x00, 0xc9, 0x24, 0x80, 0x5d, 0x75, 0xc3, 0x86, 0x8b, 0xd5, 0x6c, 0x2a, 0xcb, 0x81, 0xd3, 0x7e, 0x98, 0xe3, 0x5a, 0xdc};
static uint8_t antifuzzLittleD[SHA512_DIGEST_LENGTH] = {0x48, 0xfb, 0x10, 0xb1, 0x5f, 0x3d, 0x44, 0xa0, 0x9d, 0xc8, 0x2d, 0x02, 0xb0, 0x65, 0x81, 0xe0, 0xc0, 0xc6, 0x94, 0x78, 0xc9, 0xfd, 0x2c, 0xf8, 0xf9, 0x09, 0x36, 0x59, 0x01, 0x9a, 0x16, 0x87, 0xba, 0xec, 0xdb, 0xb3, 0x8c, 0x9e, 0x72, 0xb1, 0x21, 0x69, 0xdc, 0x41, 0x48, 0x69, 0x0f, 0x87, 0x46, 0x7f, 0x91, 0x54, 0xf5, 0x93, 0x1c, 0x5d, 0xf6, 0x65, 0xc6, 0x49, 0x6c, 0xbf, 0xd5, 0xf5};
static uint8_t antifuzzLittleE[SHA512_DIGEST_LENGTH] = {0x87, 0xc5, 0x68, 0xe0, 0x37, 0xa5, 0xfa, 0x50, 0xb1, 0xbc, 0x91, 0x1e, 0x8e, 0xe1, 0x9a, 0x77, 0xc4, 0xdd, 0x3c, 0x22, 0xbc, 0xe9, 0x93, 0x2f, 0x86, 0xfd, 0xd8, 0xa2, 0x16, 0xaf, 0xe1, 0x68, 0x1c, 0x89, 0x73, 0x7f, 0xad, 0xa6, 0x85, 0x9e, 0x91, 0x04, 0x7e, 0xec, 0xe7, 0x11, 0xec, 0x16, 0xda, 0x62, 0xd6, 0xcc, 0xb9, 0xfd, 0x0d, 0xe2, 0xc5, 0x1f, 0x13, 0x23, 0x47, 0x35, 0x0d, 0x8c};
static uint8_t antifuzzLittleF[SHA512_DIGEST_LENGTH] = {0x71, 0x1c, 0x22, 0x44, 0x8e, 0x72, 0x1e, 0x54, 0x91, 0xd8, 0x24, 0x5b, 0x49, 0x42, 0x5a, 0xa8, 0x61, 0xf1, 0xfc, 0x4a, 0x15, 0x28, 0x7f, 0x07, 0x35, 0xe2, 0x03, 0x79, 0x9b, 0x65, 0xcf, 0xfe, 0xc5, 0x0b, 0x5a, 0xbd, 0x0f, 0xdd, 0xd9, 0x1c, 0xd6, 0x43, 0xae, 0xb3, 0xb5, 0x30, 0xd4, 0x8f, 0x05, 0xe2, 0x58, 0xe7, 0xe2, 0x30, 0xa9, 0x4e, 0xd5, 0x02, 0x5c, 0x13, 0x87, 0xbb, 0x4e, 0x1b};
static uint8_t antifuzzLittleG[SHA512_DIGEST_LENGTH] = {0x19, 0xf1, 0x42, 0xb0, 0x18, 0xf3, 0x07, 0xbf, 0xdf, 0x1c, 0x70, 0x09, 0xd1, 0x5a, 0x29, 0x41, 0x7c, 0x96, 0xd8, 0x67, 0x8d, 0x29, 0x82, 0xee, 0xbc, 0xe4, 0x96, 0x1b, 0x2e, 0x67, 0xee, 0xb1, 0x18, 0xa8, 0xeb, 0xb1, 0xd7, 0x5b, 0x70, 0x08, 0x7c, 0x3e, 0x65, 0xbc, 0x79, 0x34, 0x50, 0xe3, 0xfe, 0x4a, 0x10, 0x00, 0x2b, 0xef, 0xa2, 0xd0, 0x38, 0xe5, 0xae, 0xd4, 0x79, 0x69, 0x37, 0xf2};
static uint8_t antifuzzLittleH[SHA512_DIGEST_LENGTH] = {0x22, 0x41, 0xbc, 0x8f, 0xc7, 0x07, 0x05, 0xb4, 0x2e, 0xfe, 0xad, 0x37, 0x1f, 0xd4, 0x98, 0x2c, 0x5b, 0xa6, 0x99, 0x17, 0xe5, 0xb4, 0xb8, 0x95, 0x81, 0x00, 0x02, 0x64, 0x4f, 0x03, 0x86, 0xda, 0x9c, 0x31, 0x31, 0x79, 0x34, 0x58, 0xc2, 0xbf, 0x47, 0x60, 0x84, 0x80, 0xd6, 0x4a, 0x07, 0x27, 0x81, 0x33, 0xc9, 0x99, 0x12, 0xe0, 0xba, 0x2d, 0xaf, 0x23, 0x09, 0x8f, 0x35, 0x20, 0xeb, 0x97};
static uint8_t antifuzzLittleI[SHA512_DIGEST_LENGTH] = {0x50, 0x7b, 0x55, 0x3b, 0x10, 0x6b, 0x1b, 0x99, 0x63, 0xb7, 0xaf, 0xfb, 0x34, 0xe5, 0xed, 0x14, 0xbc, 0x11, 0x60, 0xbb, 0xde, 0xa2, 0x4c, 0x09, 0x44, 0x05, 0xb3, 0x06, 0xbd, 0xcb, 0x25, 0x20, 0x82, 0x3a, 0x0c, 0x7d, 0xb7, 0xda, 0x4b, 0x51, 0xcf, 0x45, 0xcb, 0xdb, 0xad, 0x51, 0x9e, 0xec, 0xa9, 0xaf, 0xfd, 0x71, 0x03, 0xb1, 0x31, 0xd1, 0xe6, 0x5a, 0x49, 0x74, 0xba, 0x56, 0xb1, 0x8d};
static uint8_t antifuzzLittleJ[SHA512_DIGEST_LENGTH] = {0xfc, 0xd8, 0x78, 0x04, 0x93, 0xd9, 0xd1, 0x1d, 0x29, 0x03, 0x1b, 0x92, 0x8a, 0x9d, 0xa3, 0x58, 0xa6, 0xf4, 0x86, 0x27, 0xff, 0xf0, 0xcb, 0x7e, 0x80, 0xfb, 0x81, 0x07, 0xde, 0x86, 0xe0, 0xc3, 0x65, 0xdc, 0x9c, 0xf8, 0xfe, 0x2f, 0xc0, 0x5a, 0x6c, 0xe6, 0xd7, 0x58, 0x03, 0xb7, 0x8a, 0xc8, 0x94, 0xd8, 0x2a, 0x39, 0x60, 0x42, 0x31, 0x2a, 0x99, 0x5e, 0xf6, 0x3b, 0x5d, 0xd4, 0xdd, 0x11};
static uint8_t antifuzzLittleK[SHA512_DIGEST_LENGTH] = {0x2a, 0xf8, 0xa9, 0x10, 0x4b, 0x3f, 0x64, 0xed, 0x64, 0x0d, 0x8c, 0x7e, 0x29, 0x8d, 0x2d, 0x48, 0x0f, 0x03, 0xa3, 0x61, 0x0c, 0xbc, 0x2b, 0x33, 0x47, 0x43, 0x21, 0xec, 0x59, 0x02, 0x4a, 0x48, 0x59, 0x2e, 0xa8, 0x54, 0x5e, 0x41, 0xe0, 0x9d, 0x5d, 0x11, 0x08, 0x75, 0x9d, 0xf4, 0x8e, 0xde, 0x00, 0x54, 0xf2, 0x25, 0xdf, 0x39, 0xd4, 0xf0, 0xf3, 0x12, 0x45, 0x0e, 0x0a, 0xa9, 0xdd, 0x25};
static uint8_t antifuzzLittleL[SHA512_DIGEST_LENGTH] = {0xf1, 0x01, 0x27, 0x74, 0x2e, 0x07, 0xa7, 0x70, 0x57, 0x35, 0x57, 0x2f, 0x82, 0x35, 0x74, 0xb8, 0x9a, 0xaf, 0x1c, 0xbe, 0x07, 0x19, 0x35, 0xcb, 0x9e, 0x75, 0xe5, 0xcf, 0xeb, 0x81, 0x77, 0x00, 0xcb, 0x48, 0x4d, 0x11, 0x00, 0xa1, 0x0a, 0xd5, 0xc3, 0x2b, 0x59, 0xc3, 0xd6, 0x56, 0x52, 0x11, 0x10, 0x8a, 0xa9, 0xef, 0x06, 0x11, 0xd7, 0xec, 0x83, 0x0c, 0x1b, 0x66, 0xf6, 0x0e, 0x61, 0x4d};
static uint8_t antifuzzLittleM[SHA512_DIGEST_LENGTH] = {0xf1, 0x4a, 0xae, 0x6a, 0x0e, 0x05, 0x0b, 0x74, 0xe4, 0xb7, 0xb9, 0xa5, 0xb2, 0xef, 0x1a, 0x60, 0xce, 0xcc, 0xbb, 0xca, 0x39, 0xb1, 0x32, 0xae, 0x3e, 0x8b, 0xf8, 0x8d, 0x3a, 0x94, 0x6c, 0x6d, 0x86, 0x87, 0xf3, 0x26, 0x6f, 0xd2, 0xb6, 0x26, 0x41, 0x9d, 0x8b, 0x67, 0xdc, 0xf1, 0xd8, 0xd7, 0xc0, 0xfe, 0x72, 0xd4, 0x91, 0x9d, 0x9b, 0xd0, 0x5e, 0xfb, 0xd3, 0x70, 0x70, 0xcf, 0xb4, 0x1a};
static uint8_t antifuzzLittleN[SHA512_DIGEST_LENGTH] = {0x91, 0x71, 0x48, 0xec, 0x47, 0x92, 0x3f, 0x2e, 0x0e, 0x3d, 0x73, 0x14, 0x2a, 0xc4, 0xf9, 0x4e, 0xc4, 0xc7, 0x30, 0x78, 0x86, 0x5b, 0xa6, 0xd2, 0x9f, 0x0e, 0xa1, 0x72, 0xcd, 0x6f, 0x4b, 0xf3, 0x4d, 0xb6, 0x99, 0xaf, 0x5c, 0x33, 0x53, 0x5d, 0x36, 0x94, 0xd4, 0xae, 0xf9, 0x1a, 0x11, 0xf9, 0x16, 0x00, 0x4d, 0x03, 0x82, 0xf7, 0x94, 0x44, 0x8a, 0x85, 0x50, 0x62, 0x3d, 0x34, 0xc9, 0x85};
static uint8_t antifuzzLittleO[SHA512_DIGEST_LENGTH] = {0xcd, 0xed, 0x74, 0x74, 0x0d, 0x4b, 0xbf, 0xd4, 0xeb, 0x12, 0x6d, 0x6d, 0xe4, 0x54, 0xb5, 0x9e, 0x2d, 0x63, 0x1f, 0x36, 0xc0, 0xae, 0x0d, 0x23, 0x25, 0xb5, 0xe2, 0xbe, 0x4d, 0xa2, 0xbe, 0xfe, 0x79, 0x21, 0x06, 0xb9, 0x84, 0x22, 0xad, 0x24, 0xc0, 0x92, 0xe8, 0xf1, 0x84, 0xb2, 0xff, 0x4b, 0xe0, 0xbb, 0xbc, 0xdc, 0xd2, 0x78, 0xdb, 0x6c, 0x24, 0x27, 0x53, 0x3b, 0x2e, 0x92, 0x64, 0xd1};
static uint8_t antifuzzLittleP[SHA512_DIGEST_LENGTH] = {0x92, 0x98, 0x72, 0x83, 0x8c, 0xb9, 0xcf, 0xe6, 0x57, 0x8e, 0x11, 0xf0, 0xa3, 0x23, 0x43, 0x8a, 0xee, 0x5a, 0xe7, 0xf6, 0x1d, 0x41, 0x41, 0x2d, 0x62, 0xdb, 0x72, 0xb2, 0x5d, 0xac, 0x52, 0x01, 0x9d, 0xe2, 0xd6, 0xa3, 0x55, 0xeb, 0x2d, 0x03, 0x33, 0x36, 0xfb, 0x70, 0xe7, 0x3f, 0x0e, 0xc0, 0xaf, 0xec, 0xa3, 0xef, 0x36, 0xdd, 0x8a, 0x90, 0xd8, 0x3f, 0x99, 0x8f, 0xee, 0x23, 0xb7, 0x8d};
static uint8_t antifuzzLittleQ[SHA512_DIGEST_LENGTH] = {0x2e, 0x96, 0x77, 0x22, 0x32, 0x48, 0x7f, 0xb3, 0xa0, 0x58, 0xd5, 0x8f, 0x2c, 0x31, 0x00, 0x23, 0xe0, 0x7e, 0x40, 0x17, 0xc9, 0x4d, 0x56, 0xcc, 0x5f, 0xae, 0x4b, 0x54, 0xb4, 0x46, 0x05, 0xf4, 0x2a, 0x75, 0xb0, 0xb1, 0xf3, 0x58, 0x99, 0x1f, 0x8c, 0x6c, 0xbe, 0x9b, 0x68, 0xb6, 0x4e, 0x5b, 0x2a, 0x09, 0xd0, 0xad, 0x23, 0xfc, 0xac, 0x07, 0xee, 0x9a, 0x91, 0x98, 0xa7, 0x45, 0xe1, 0xd5};
static uint8_t antifuzzLittleR[SHA512_DIGEST_LENGTH] = {0xa8, 0x82, 0xf0, 0xac, 0x84, 0x8b, 0x0b, 0x6b, 0x4c, 0xa7, 0xb4, 0x2b, 0xfa, 0x1d, 0x26, 0x6a, 0xfd, 0x0d, 0xde, 0xba, 0x92, 0x04, 0xae, 0x57, 0xa9, 0x84, 0xa6, 0x93, 0x76, 0xd5, 0x98, 0x16, 0xb1, 0xef, 0x3f, 0x4d, 0x44, 0x2e, 0xa8, 0xa7, 0x03, 0x96, 0x06, 0x7f, 0xf5, 0xb7, 0x0e, 0x0a, 0xe8, 0xea, 0xb3, 0x93, 0x5b, 0x61, 0x7b, 0x8e, 0x36, 0x6d, 0x8e, 0x35, 0xc3, 0xbf, 0xe1, 0x4c};
static uint8_t antifuzzLittleS[SHA512_DIGEST_LENGTH] = {0x2c, 0x1e, 0xe6, 0x83, 0x72, 0x21, 0x5b, 0x1c, 0xe0, 0x64, 0x42, 0x6b, 0x5c, 0xdb, 0xd4, 0xef, 0x25, 0x81, 0xac, 0xe0, 0xdd, 0x3b, 0x21, 0xfa, 0x2b, 0xe2, 0x7f, 0x36, 0x48, 0x27, 0x24, 0x2e, 0x83, 0xf6, 0x8b, 0x68, 0xbe, 0x03, 0xf5, 0xb3, 0xe2, 0x4b, 0xe5, 0xd1, 0xb4, 0x31, 0x5f, 0x98, 0xa0, 0xa9, 0x6d, 0x19, 0x71, 0x3f, 0xb3, 0xa1, 0x9d, 0xc4, 0x55, 0xfb, 0x6a, 0xdc, 0x34, 0x31};
static uint8_t antifuzzLittleT[SHA512_DIGEST_LENGTH] = {0x99, 0xf9, 0x7d, 0x45, 0x5d, 0x5d, 0x62, 0xb2, 0x4f, 0x3a, 0x94, 0x2a, 0x1a, 0xbc, 0x3f, 0xa8, 0x86, 0x3f, 0xc0, 0xce, 0x20, 0x37, 0xf5, 0x2f, 0x09, 0xbd, 0x78, 0x5b, 0x22, 0xb8, 0x00, 0xd4, 0xf2, 0xe7, 0xb2, 0xb6, 0x14, 0xcb, 0x60, 0x0f, 0xfc, 0x2a, 0x4f, 0xe2, 0x46, 0x79, 0x84, 0x5b, 0x24, 0x88, 0x6d, 0x69, 0xbb, 0x77, 0x6f, 0xcf, 0xa4, 0x6e, 0x54, 0xd1, 0x88, 0x88, 0x9c, 0x6f};
static uint8_t antifuzzLittleU[SHA512_DIGEST_LENGTH] = {0x58, 0x00, 0x79, 0x11, 0xbf, 0x9f, 0x66, 0x71, 0x1e, 0xf6, 0x5e, 0x80, 0x7b, 0x26, 0xc3, 0x96, 0xa2, 0xd6, 0xfb, 0x46, 0x4f, 0x43, 0x81, 0x52, 0x0c, 0x5d, 0x4a, 0x57, 0x5d, 0xbb, 0x81, 0x51, 0x0f, 0x79, 0xd3, 0x5e, 0x34, 0x96, 0x04, 0x12, 0x8a, 0x77, 0x1a, 0xcf, 0x2a, 0x11, 0x7a, 0x2a, 0xfd, 0xed, 0xc0, 0x12, 0xd8, 0x3b, 0x0e, 0xb8, 0x22, 0x66, 0x8a, 0xee, 0x0d, 0xef, 0x47, 0x47};
static uint8_t antifuzzLittleV[SHA512_DIGEST_LENGTH] = {0x7b, 0x07, 0x76, 0xdb, 0xac, 0x74, 0xa9, 0xab, 0xb8, 0xa0, 0xd0, 0x11, 0x9c, 0x73, 0xae, 0x82, 0xef, 0xbb, 0x1b, 0x95, 0xaf, 0x00, 0x9f, 0x06, 0x69, 0xe2, 0xb5, 0x2c, 0x96, 0x64, 0xf7, 0xfb, 0xb4, 0x58, 0xdd, 0xf3, 0xab, 0xd7, 0xcc, 0xf0, 0x61, 0x7a, 0xb6, 0x93, 0x62, 0xa1, 0x3a, 0xde, 0x04, 0x6c, 0x4f, 0x19, 0x49, 0x07, 0x10, 0xe5, 0xd8, 0x93, 0x7b, 0xa7, 0x2e, 0xfa, 0x90, 0xaa};
static uint8_t antifuzzLittleW[SHA512_DIGEST_LENGTH] = {0xaa, 0x66, 0x50, 0x98, 0x91, 0xad, 0x28, 0x03, 0x03, 0x49, 0xba, 0x95, 0x81, 0xe8, 0xc9, 0x25, 0x28, 0xfa, 0xab, 0x6a, 0x34, 0x34, 0x90, 0x61, 0xa4, 0x4b, 0x6f, 0x8f, 0xcd, 0x8d, 0x68, 0x77, 0xa6, 0x7b, 0x05, 0x50, 0x89, 0x83, 0xf1, 0x2f, 0x86, 0x10, 0x30, 0x2d, 0x17, 0x83, 0x40, 0x1a, 0x07, 0xec, 0x41, 0xc7, 0xe9, 0xeb, 0xd6, 0x56, 0xde, 0x34, 0xec, 0x60, 0xd8, 0x4d, 0x95, 0x11};
static uint8_t antifuzzLittleX[SHA512_DIGEST_LENGTH] = {0xa4, 0xab, 0xd4, 0x44, 0x8c, 0x49, 0x56, 0x2d, 0x82, 0x81, 0x15, 0xd1, 0x3a, 0x1f, 0xcc, 0xea, 0x92, 0x7f, 0x52, 0xb4, 0xd5, 0x45, 0x92, 0x97, 0xf8, 0xb4, 0x3e, 0x42, 0xda, 0x89, 0x23, 0x8b, 0xc1, 0x36, 0x26, 0xe4, 0x3d, 0xcb, 0x38, 0xdd, 0xb0, 0x82, 0x48, 0x89, 0x27, 0xec, 0x90, 0x4f, 0xb4, 0x20, 0x57, 0x44, 0x39, 0x83, 0xe8, 0x85, 0x85, 0x17, 0x9d, 0x50, 0x55, 0x1a, 0xfe, 0x62};
static uint8_t antifuzzLittleY[SHA512_DIGEST_LENGTH] = {0x12, 0x1b, 0x47, 0x74, 0xa7, 0x59, 0x92, 0x4a, 0x29, 0x29, 0xc4, 0xa4, 0x12, 0xfb, 0x6e, 0x31, 0xb9, 0xaa, 0xa7, 0x46, 0x46, 0x68, 0x40, 0xef, 0xcc, 0x4a, 0x76, 0xd6, 0x9a, 0x94, 0x14, 0x9e, 0x23, 0x64, 0xe3, 0x98, 0x3d, 0x64, 0x6f, 0xea, 0xfa, 0xa1, 0xb5, 0x11, 0x78, 0x5e, 0x5c, 0x9e, 0x90, 0xae, 0xdc, 0x30, 0xda, 0x6a, 0x6b, 0xea, 0xd5, 0x52, 0x0e, 0xcc, 0x99, 0xc6, 0x62, 0x6a};
static uint8_t antifuzzLittleZ[SHA512_DIGEST_LENGTH] = {0x5a, 0xe6, 0x25, 0x66, 0x5f, 0x3e, 0x0b, 0xd0, 0xa0, 0x65, 0xed, 0x07, 0xa4, 0x19, 0x89, 0xe4, 0x02, 0x5b, 0x79, 0xd1, 0x39, 0x30, 0xa2, 0xa8, 0xc5, 0x7d, 0x6b, 0x43, 0x25, 0x22, 0x67, 0x07, 0xd9, 0x56, 0xa0, 0x82, 0xd1, 0xe9, 0x1b, 0x4d, 0x96, 0xa7, 0x93, 0x56, 0x2d, 0xf9, 0x8f, 0xd0, 0x3c, 0x9d, 0xcf, 0x74, 0x3c, 0x9c, 0x7b, 0x4e, 0x30, 0x55, 0xd4, 0xf9, 0xf0, 0x9b, 0xa0, 0x15};
static uint8_t antifuzzDigit0[SHA512_DIGEST_LENGTH] = {0x31, 0xbc, 0xa0, 0x20, 0x94, 0xeb, 0x78, 0x12, 0x6a, 0x51, 0x7b, 0x20, 0x6a, 0x88, 0xc7, 0x3c, 0xfa, 0x9e, 0xc6, 0xf7, 0x04, 0xc7, 0x03, 0x0d, 0x18, 0x21, 0x2c, 0xac, 0xe8, 0x20, 0xf0, 0x25, 0xf0, 0x0b, 0xf0, 0xea, 0x68, 0xdb, 0xf3, 0xf3, 0xa5, 0x43, 0x6c, 0xa6, 0x3b, 0x53, 0xbf, 0x7b, 0xf8, 0x0a, 0xd8, 0xd5, 0xde, 0x7d, 0x83, 0x59, 0xd0, 0xb7, 0xfe, 0xd9, 0xdb, 0xc3, 0xab, 0x99};
static uint8_t antifuzzDigit1[SHA512_DIGEST_LENGTH] = {0x4d, 0xff, 0x4e, 0xa3, 0x40, 0xf0, 0xa8, 0x23, 0xf1, 0x5d, 0x3f, 0x4f, 0x01, 0xab, 0x62, 0xea, 0xe0, 0xe5, 0xda, 0x57, 0x9c, 0xcb, 0x85, 0x1f, 0x8d, 0xb9, 0xdf, 0xe8, 0x4c, 0x58, 0xb2, 0xb3, 0x7b, 0x89, 0x90, 0x3a, 0x74, 0x0e, 0x1e, 0xe1, 0x72, 0xda, 0x79, 0x3a, 0x6e, 0x79, 0xd5, 0x60, 0xe5, 0xf7, 0xf9, 0xbd, 0x05, 0x8a, 0x12, 0xa2, 0x80, 0x43, 0x3e, 0xd6, 0xfa, 0x46, 0x51, 0x0a};
static uint8_t antifuzzDigit2[SHA512_DIGEST_LENGTH] = {0x40, 0xb2, 0x44, 0x11, 0x26, 0x41, 0xdd, 0x78, 0xdd, 0x4f, 0x93, 0xb6, 0xc9, 0x19, 0x0d, 0xd4, 0x6e, 0x00, 0x99, 0x19, 0x4d, 0x5a, 0x44, 0x25, 0x7b, 0x7e, 0xfa, 0xd6, 0xef, 0x9f, 0xf4, 0x68, 0x3d, 0xa1, 0xed, 0xa0, 0x24, 0x44, 0x48, 0xcb, 0x34, 0x3a, 0xa6, 0x88, 0xf5, 0xd3, 0xef, 0xd7, 0x31, 0x4d, 0xaf, 0xe5, 0x80, 0xac, 0x0b, 0xcb, 0xf1, 0x15, 0xae, 0xca, 0x9e, 0x8d, 0xc1, 0x14};
static uint8_t antifuzzDigit3[SHA512_DIGEST_LENGTH] = {0x3b, 0xaf, 0xbf, 0x08, 0x88, 0x2a, 0x2d, 0x10, 0x13, 0x30, 0x93, 0xa1, 0xb8, 0x43, 0x3f, 0x50, 0x56, 0x3b, 0x93, 0xc1, 0x4a, 0xcd, 0x05, 0xb7, 0x90, 0x28, 0xeb, 0x1d, 0x12, 0x79, 0x90, 0x27, 0x24, 0x14, 0x50, 0x98, 0x06, 0x51, 0x99, 0x45, 0x01, 0x42, 0x3a, 0x66, 0xc2, 0x76, 0xae, 0x26, 0xc4, 0x3b, 0x73, 0x9b, 0xc6, 0x5c, 0x4e, 0x16, 0xb1, 0x0c, 0x3a, 0xf6, 0xc2, 0x02, 0xae, 0xbb};
static uint8_t antifuzzDigit4[SHA512_DIGEST_LENGTH] = {0xa3, 0x21, 0xd8, 0xb4, 0x05, 0xe3, 0xef, 0x26, 0x04, 0x95, 0x98, 0x47, 0xb3, 0x6d, 0x17, 0x1e, 0xeb, 0xeb, 0xc4, 0xa8, 0x94, 0x1d, 0xc7, 0x0a, 0x47, 0x84, 0x93, 0x5a, 0x4f, 0xca, 0x5d, 0x58, 0x13, 0xde, 0x84, 0xdf, 0xa0, 0x49, 0xf0, 0x65, 0x49, 0xaa, 0x61, 0xb2, 0x08, 0x48, 0xc1, 0x63, 0x3c, 0xe8, 0x1b, 0x67, 0x52, 0x86, 0xea, 0x8f, 0xb5, 0x3d, 0xb2, 0x40, 0xd8, 0x31, 0xc5, 0x68};
static uint8_t antifuzzDigit5[SHA512_DIGEST_LENGTH] = {0x06, 0xdf, 0x05, 0x37, 0x19, 0x81, 0xa2, 0x37, 0xd0, 0xed, 0x11, 0x47, 0x2f, 0xae, 0x7c, 0x94, 0xc9, 0xac, 0x0e, 0xff, 0x1d, 0x05, 0x41, 0x35, 0x16, 0x71, 0x0d, 0x17, 0xb1, 0x0a, 0x4f, 0xb6, 0xf4, 0x51, 0x7b, 0xda, 0x4a, 0x69, 0x5f, 0x02, 0xd0, 0xa7, 0x3d, 0xd4, 0xdb, 0x54, 0x3b, 0x46, 0x53, 0xdf, 0x28, 0xf5, 0xd0, 0x9d, 0xab, 0x86, 0xf9, 0x2f, 0xfb, 0x9b, 0x86, 0xd0, 0x1e, 0x25};
static uint8_t antifuzzDigit6[SHA512_DIGEST_LENGTH] = {0x3c, 0x9a, 0xd5, 0x51, 0x47, 0xa7, 0x14, 0x4f, 0x60, 0x67, 0x32, 0x7c, 0x3b, 0x82, 0xea, 0x70, 0xe7, 0xc5, 0x42, 0x6a, 0xdd, 0x9c, 0xee, 0xa4, 0xd0, 0x7d, 0xc2, 0x90, 0x22, 0x39, 0xbf, 0x9e, 0x04, 0x9b, 0x88, 0x62, 0x5e, 0xb6, 0x5d, 0x01, 0x4a, 0x77, 0x18, 0xf7, 0x93, 0x54, 0x60, 0x8c, 0xab, 0x09, 0x21, 0x78, 0x2c, 0x64, 0x3f, 0x02, 0x08, 0x98, 0x3f, 0xff, 0xa3, 0x58, 0x2e, 0x40};
static uint8_t antifuzzDigit7[SHA512_DIGEST_LENGTH] = {0xf0, 0x52, 0x10, 0xc5, 0xb4, 0x26, 0x3f, 0x0e, 0xc4, 0xc3, 0x99, 0x5b, 0xda, 0xb4, 0x58, 0xd8, 0x1d, 0x39, 0x53, 0xf3, 0x54, 0xa9, 0x10, 0x95, 0x20, 0xf1, 0x59, 0xdb, 0x1e, 0x88, 0x00, 0xbc, 0xd4, 0x5b, 0x97, 0xc5, 0x6d, 0xce, 0x90, 0xa1, 0xfc, 0x27, 0xab, 0x03, 0xe0, 0xb8, 0xa9, 0xaf, 0x86, 0x73, 0x74, 0x70, 0x23, 0xc4, 0x06, 0x29, 0x93, 0x74, 0x11, 0x6d, 0x6f, 0x96, 0x69, 0x81};
static uint8_t antifuzzDigit8[SHA512_DIGEST_LENGTH] = {0xbc, 0x23, 0xb8, 0xb0, 0x17, 0x72, 0xd2, 0xdd, 0x67, 0xef, 0xb8, 0xfe, 0x1a, 0x5e, 0x6b, 0xd0, 0xf4, 0x4b, 0x97, 0xc3, 0x61, 0x01, 0xbe, 0x6c, 0xc0, 0x9f, 0x25, 0x3b, 0x53, 0xe6, 0x8d, 0x67, 0xa2, 0x2e, 0x46, 0x43, 0x06, 0x8d, 0xfd, 0x13, 0x41, 0x98, 0x01, 0x34, 0xea, 0x57, 0x57, 0x0a, 0xcf, 0x65, 0xe3, 0x06, 0xe4, 0xd9, 0x6c, 0xef, 0x4d, 0x56, 0x03, 0x84, 0x89, 0x4c, 0x88, 0xa4};
static uint8_t antifuzzDigit9[SHA512_DIGEST_LENGTH] = {0x0d, 0xc5, 0x26, 0xd8, 0xc4, 0xfa, 0x04, 0x08, 0x4f, 0x4b, 0x2a, 0x64, 0x33, 0xf4, 0xcd, 0x14, 0x66, 0x4b, 0x93, 0xdf, 0x9f, 0xb8, 0xa9, 0xe0, 0x0b, 0x77, 0xba, 0x89, 0x0b, 0x83, 0x70, 0x4d, 0x24, 0x94, 0x4c, 0x93, 0xca, 0xa6, 0x92, 0xb5, 0x10, 0x85, 0xbb, 0x47, 0x6f, 0x81, 0x85, 0x2c, 0x27, 0xe7, 0x93, 0x60, 0x0f, 0x13, 0x7a, 0xe3, 0x92, 0x90, 0x18, 0xcd, 0x4c, 0x8f, 0x1a, 0x45};
static uint8_t antifuzzSymbolPlus[SHA512_DIGEST_LENGTH] = {0x60, 0x3e, 0x4e, 0xaa, 0x41, 0x17, 0x69, 0xb6, 0xd8, 0x3a, 0x13, 0xbf, 0x2f, 0xde, 0x63, 0x28, 0x93, 0x22, 0x34, 0x3f, 0x8c, 0x68, 0x3f, 0xf6, 0x1d, 0x83, 0x22, 0x01, 0xe1, 0xcf, 0x4d, 0x3e, 0x43, 0x2a, 0x1d, 0x98, 0x19, 0xe3, 0x27, 0xfe, 0x14, 0xda, 0x61, 0xab, 0x65, 0xee, 0x70, 0xde, 0xe3, 0x9d, 0x4a, 0x3f, 0x88, 0xa7, 0x15, 0x30, 0xbd, 0xe2, 0xca, 0xe7, 0x3d, 0x36, 0x71, 0x0b};
static uint8_t antifuzzSymbolSlash[SHA512_DIGEST_LENGTH] = {0x5c, 0x86, 0xf0, 0x34, 0x4e, 0xd2, 0x49, 0x42, 0x5c, 0x8a, 0xad, 0x3f, 0x27, 0x2b, 0x72, 0xa2, 0xce, 0x0f, 0xf3, 0x88, 0x79, 0x1f, 0x31, 0x49, 0x7e, 0xaf, 0x25, 0x7f, 0xa7, 0x26, 0x29, 0x48, 0x7f, 0xaa, 0xfd, 0x7f, 0xd2, 0x7e, 0xb0, 0xdd, 0x63, 0x55, 0xd5, 0x50, 0x9e, 0x2f, 0x3f, 0xaf, 0x76, 0x71, 0x10, 0x15, 0xcd, 0x92, 0x07, 0xd2, 0x48, 0xd5, 0x50, 0xfd, 0xea, 0x15, 0x27, 0x4f};

static uint8_t antifuzzSymbolQuestionMark[SHA512_DIGEST_LENGTH] = {0xca, 0x63, 0xc0, 0x7a, 0xd3, 0x5d, 0x8c, 0x9f, 0xb0, 0xc9, 0x2d, 0x61, 0x46, 0x75, 0x9b, 0x12, 0x2d, 0x4e, 0xc5, 0xd3, 0xf6, 0x7e, 0xbe, 0x2f, 0x30, 0xdd, 0xb6, 0x9f, 0x9e, 0x6c, 0x9f, 0xd3, 0xbf, 0x31, 0xa5, 0xe4, 0x08, 0xb0, 0x8f, 0x1d, 0x4d, 0x9c, 0xd6, 0x81, 0x20, 0xcc, 0xed, 0x9e, 0x57, 0xf0, 0x10, 0xbe, 0xf3, 0xcd, 0xe9, 0x76, 0x53, 0xfe, 0xd5, 0x47, 0x0d, 0xa7, 0xd1, 0xa0};
static uint8_t antifuzzSymbolAsterisk[SHA512_DIGEST_LENGTH] = {0x78, 0x46, 0xcd, 0xd4, 0xc2, 0xb9, 0x05, 0x27, 0x68, 0xb8, 0x90, 0x16, 0x40, 0x12, 0x2e, 0x52, 0x82, 0xe0, 0xb8, 0x33, 0xa6, 0xa5, 0x83, 0x12, 0xa7, 0x76, 0x34, 0x72, 0xd4, 0x48, 0xee, 0x23, 0x78, 0x1c, 0x7f, 0x08, 0xd9, 0x07, 0x93, 0xfd, 0xfe, 0x71, 0xff, 0xe7, 0x42, 0x38, 0xcf, 0x6e, 0x4a, 0xa7, 0x78, 0xcc, 0x9b, 0xb8, 0xce, 0xc0, 0x3e, 0xa7, 0x26, 0x8d, 0x48, 0x93, 0xa5, 0x02};
static uint8_t antifuzzSymbolBackslash[SHA512_DIGEST_LENGTH] = {0x0a, 0x0c, 0xd1, 0x16, 0xc2, 0xc5, 0x7f, 0xb1, 0x25, 0xfd, 0x9a, 0xda, 0x13, 0x1f, 0x6c, 0xa9, 0x64, 0x58, 0x7a, 0x99, 0x58, 0xa2, 0x14, 0x81, 0x4a, 0x62, 0x3d, 0xb1, 0x82, 0x1e, 0xd5, 0xce, 0x32, 0xda, 0xee, 0xc4, 0x08, 0x5a, 0x14, 0xe3, 0x1d, 0x90, 0x0a, 0x35, 0x7b, 0x1e, 0x25, 0x49, 0x31, 0x9b, 0x2e, 0x0c, 0xc2, 0xc8, 0xcf, 0xba, 0xfc, 0x6a, 0x4a, 0x4a, 0xaf, 0xeb, 0xe2, 0x03};

static uint8_t antifuzzSquareBracketOpen[SHA512_DIGEST_LENGTH] = {0xe8, 0xb3, 0x4c, 0xbf, 0x06, 0x1c, 0xa4, 0xc5, 0x8e, 0x89, 0xb4, 0x0e, 0x79, 0x7b, 0xee, 0xfd, 0xb6, 0x63, 0xb6, 0x81, 0xa9, 0x6e, 0x2d, 0x1c, 0xcd, 0x8f, 0x03, 0xf9, 0xb5, 0x2e, 0xb4, 0xe0, 0x0b, 0x66, 0x1d, 0x01, 0x7d, 0x1c, 0x73, 0xf2, 0x74, 0x69, 0x77, 0xa8, 0xe6, 0x1e, 0xfc, 0x18, 0xd3, 0xd3, 0xdd, 0xe5, 0xf6, 0x69, 0xad, 0x90, 0x62, 0xcf, 0x53, 0x3c, 0x30, 0xb2, 0xfb, 0xb1};
static uint8_t antifuzzSquareBracketClose[SHA512_DIGEST_LENGTH] = {0xde, 0xcb, 0xb4, 0xe9, 0xa4, 0x43, 0x9d, 0x44, 0x0a, 0x14, 0xd7, 0xe8, 0x00, 0x4a, 0xf1, 0x06, 0x56, 0xb4, 0x7b, 0xbb, 0x04, 0x11, 0x87, 0x82, 0x51, 0xc6, 0xe8, 0xc4, 0x27, 0x33, 0xa8, 0xc6, 0x80, 0xe6, 0xbc, 0xbd, 0x70, 0xea, 0xdb, 0x71, 0xfd, 0x0c, 0x80, 0xc3, 0xb1, 0x81, 0x4b, 0xdf, 0xec, 0x06, 0x80, 0xef, 0x49, 0x96, 0x02, 0xf5, 0x67, 0x2f, 0x27, 0x43, 0x6d, 0xe4, 0x88, 0xa4};
static uint8_t antifuzzSemicolon[SHA512_DIGEST_LENGTH] = {0xe2, 0x8e, 0x54, 0x7f, 0x81, 0x38, 0x10, 0x6f, 0xbd, 0xd0, 0xc6, 0xfc, 0xdb, 0x41, 0x47, 0xd9, 0x81, 0x43, 0x7f, 0x82, 0x2e, 0x5f, 0x86, 0xdf, 0x53, 0x04, 0x02, 0xee, 0xb7, 0x8a, 0xd5, 0x98, 0x60, 0x71, 0x75, 0x89, 0x04, 0xa3, 0x0a, 0xdb, 0x7d, 0xf4, 0x5c, 0x81, 0x0b, 0x68, 0x52, 0x49, 0xf0, 0x78, 0x8f, 0x7d, 0xf4, 0xbd, 0x98, 0xfe, 0xb4, 0x30, 0xf8, 0xee, 0x5c, 0xc2, 0x2b, 0x1c};
static uint8_t antifuzzBracketOpen[SHA512_DIGEST_LENGTH] = {0x2d, 0xa6, 0xfb, 0x55, 0x20, 0x8f, 0x81, 0x65, 0xa1, 0x70, 0xf1, 0x87, 0xf1, 0xdf, 0xca, 0xfe, 0xe2, 0x50, 0x9f, 0x03, 0xe4, 0x71, 0x56, 0x78, 0x60, 0x10, 0x78, 0xf5, 0x2e, 0x34, 0x7d, 0xbe, 0x96, 0xfa, 0x0e, 0x71, 0x47, 0x96, 0x0e, 0x1e, 0xad, 0x04, 0x6d, 0x37, 0x1f, 0xd8, 0xeb, 0xfb, 0x0c, 0x7f, 0xaa, 0x99, 0x22, 0xa0, 0xed, 0x35, 0xce, 0xb8, 0x9c, 0x9c, 0x44, 0x59, 0x09, 0xa1};
static uint8_t antifuzzBracketClose[SHA512_DIGEST_LENGTH] = {0x89, 0x97, 0x0c, 0xf3, 0x5e, 0x0c, 0x41, 0x43, 0xeb, 0x3f, 0x23, 0x83, 0x88, 0x1f, 0x82, 0xce, 0x45, 0xc6, 0x64, 0xb7, 0xd9, 0x1d, 0xca, 0xf1, 0x3f, 0x48, 0x83, 0x42, 0x64, 0x6b, 0x6d, 0x0d, 0xaf, 0xf6, 0x28, 0x8c, 0x20, 0x0f, 0x9b, 0x81, 0x2b, 0xb2, 0x06, 0x1c, 0x96, 0x81, 0xae, 0xae, 0x9c, 0x91, 0xd6, 0x65, 0x44, 0x05, 0x2f, 0x0f, 0x7b, 0x5a, 0xa2, 0x9e, 0x85, 0x39, 0xa3, 0x44};
static uint8_t antifuzzLinefeed[SHA512_DIGEST_LENGTH] = {0x9f, 0x71, 0x02, 0xcc, 0xf3, 0x7b, 0x04, 0x2a, 0xf0, 0xa2, 0xf9, 0xd8, 0x4f, 0xf2, 0x58, 0x80, 0x7b, 0x20, 0x5c, 0x5c, 0x0d, 0x99, 0xda, 0x7c, 0xcd, 0x44, 0xce, 0x0e, 0x7e, 0xe4, 0xd2, 0x74, 0x65, 0xc1, 0x9f, 0x66, 0x19, 0x8a, 0x2a, 0xfe, 0xf6, 0x99, 0xe0, 0xdb, 0x38, 0xb5, 0xdf, 0xca, 0x04, 0x37, 0xdf, 0x66, 0xe7, 0xf9, 0x14, 0x06, 0x12, 0x29, 0x69, 0x30, 0xa4, 0x88, 0x1b, 0x2c};
static uint8_t antifuzzSpace[SHA512_DIGEST_LENGTH] = {0xf9, 0x0d, 0xdd, 0x77, 0xe4, 0x00, 0xdf, 0xe6, 0xa3, 0xfc, 0xf4, 0x79, 0xb0, 0x0b, 0x1e, 0xe2, 0x9e, 0x70, 0x15, 0xc5, 0xbb, 0x8c, 0xd7, 0x0f, 0x5f, 0x15, 0xb4, 0x88, 0x6c, 0xc3, 0x39, 0x27, 0x5f, 0xf5, 0x53, 0xfc, 0x8a, 0x05, 0x3f, 0x8d, 0xdc, 0x73, 0x24, 0xf4, 0x51, 0x68, 0xcf, 0xfa, 0xf8, 0x1f, 0x8c, 0x3a, 0xc9, 0x39, 0x96, 0xf6, 0x53, 0x6e, 0xef, 0x38, 0xe5, 0xe4, 0x07, 0x68};
static uint8_t antifuzzMinus[SHA512_DIGEST_LENGTH] = {0x7c, 0x0b, 0x0d, 0x99, 0xa6, 0xe4, 0xc3, 0x3c, 0xda, 0x0f, 0x6f, 0x63, 0x54, 0x7f, 0x87, 0x8f, 0x4d, 0xd9, 0xf4, 0x86, 0xdf, 0xe5, 0xd0, 0x44, 0x6c, 0xe0, 0x04, 0xb1, 0xc0, 0xff, 0x28, 0xf1, 0x91, 0xff, 0x86, 0xf5, 0xd5, 0x93, 0x3d, 0x36, 0x14, 0xcc, 0xee, 0xe6, 0xfb, 0xbd, 0xc1, 0x7e, 0x65, 0x88, 0x81, 0xd3, 0xa1, 0x64, 0xdf, 0xa5, 0xd6, 0xf4, 0xc6, 0x99, 0xb2, 0x12, 0x6e, 0x3d};

static uint8_t antifuzzStringYes[SHA512_DIGEST_LENGTH] = {0x81, 0xe9, 0x2f, 0x5d, 0x90, 0x68, 0x4d, 0xb6, 0x63, 0x83, 0x44, 0x86, 0x9c, 0x82, 0xe7, 0x84, 0xb5, 0x27, 0x0b, 0x51, 0x38, 0x11, 0x08, 0x0b, 0xdb, 0xa9, 0x05, 0x82, 0x0b, 0xe1, 0xb0, 0x33, 0x1b, 0xe8, 0xfb, 0x73, 0x29, 0xe4, 0xc7, 0xa6, 0xf9, 0x78, 0x46, 0xc1, 0xb2, 0x11, 0x57, 0x20, 0x42, 0xa0, 0xc5, 0xbf, 0xc7, 0xd4, 0x87, 0xa7, 0x4c, 0xab, 0x02, 0x21, 0xc1, 0x96, 0x85, 0xc5};
static uint8_t antifuzzStringNo[SHA512_DIGEST_LENGTH] = {0x22, 0x49, 0x4a, 0xf5, 0x56, 0xa0, 0x78, 0x26, 0x23, 0x72, 0x9d, 0x0b, 0x5a, 0x98, 0x78, 0xf8, 0x0a, 0xa6, 0xc2, 0x1a, 0x6f, 0x51, 0xd3, 0x46, 0x77, 0x18, 0x42, 0xd6, 0x13, 0xf5, 0x10, 0x73, 0xc3, 0xb0, 0x2f, 0xab, 0x21, 0x1b, 0xaf, 0xf4, 0x2f, 0xb1, 0x99, 0x8f, 0x38, 0xb7, 0x72, 0x50, 0xdc, 0x7a, 0x1c, 0x71, 0xdd, 0x98, 0xb4, 0xb0, 0x0c, 0xae, 0x96, 0x20, 0xa6, 0x10, 0x2a, 0xd7};
static uint8_t antifuzzStringTrue[SHA512_DIGEST_LENGTH] = {0x91, 0x20, 0xcd, 0x5f, 0xae, 0xf0, 0x7a, 0x08, 0xe9, 0x71, 0xff, 0x02, 0x4a, 0x3f, 0xcb, 0xea, 0x1e, 0x3a, 0x6b, 0x44, 0x14, 0x2a, 0x6d, 0x82, 0xca, 0x28, 0xc6, 0xc4, 0x2e, 0x4f, 0x85, 0x25, 0x95, 0xbc, 0xf5, 0x3d, 0x81, 0xd7, 0x76, 0xf1, 0x05, 0x41, 0x04, 0x5a, 0xbd, 0xb7, 0xc3, 0x79, 0x50, 0x62, 0x94, 0x15, 0xd0, 0xdc, 0x66, 0xc8, 0xd8, 0x6c, 0x64, 0xa5, 0x60, 0x6d, 0x32, 0xde};
static uint8_t antifuzzStringFalse[SHA512_DIGEST_LENGTH] = {0x71, 0x9f, 0xa6, 0x7e, 0xef, 0x49, 0xc4, 0xb2, 0xa2, 0xb8, 0x3f, 0x0c, 0x62, 0xbd, 0xdd, 0x88, 0xc1, 0x06, 0xaa, 0xad, 0xb7, 0xe2, 0x1a, 0xe0, 0x57, 0xc8, 0x80, 0x2b, 0x70, 0x0e, 0x36, 0xf8, 0x1f, 0xe3, 0xf1, 0x44, 0x81, 0x2d, 0x8b, 0x05, 0xd6, 0x6d, 0xc6, 0x63, 0xd9, 0x08, 0xb2, 0x56, 0x45, 0xe1, 0x53, 0x26, 0x2c, 0xf6, 0xd4, 0x57, 0xaa, 0x34, 0xe6, 0x84, 0xaf, 0x9e, 0x32, 0x8d};
static uint8_t antifuzzStringOn[SHA512_DIGEST_LENGTH] = {0xb7, 0xda, 0x84, 0x3e, 0xec, 0x64, 0xc9, 0x3c, 0xb7, 0xbb, 0xee, 0x2e, 0x84, 0xe7, 0xf5, 0x30, 0xbb, 0x7c, 0x9b, 0x63, 0x7f, 0x02, 0x86, 0xfe, 0x5a, 0x6e, 0xdc, 0x72, 0xa6, 0x1a, 0x6e, 0x21, 0x93, 0xc4, 0x58, 0x84, 0xfd, 0x6b, 0x8e, 0x13, 0xcb, 0x31, 0x9f, 0x29, 0xd6, 0x02, 0x31, 0x5c, 0x4b, 0xcf, 0x70, 0xc3, 0xf7, 0x4a, 0xc2, 0x22, 0x24, 0xf3, 0xaa, 0xce, 0x6e, 0x1f, 0x20, 0xae};
static uint8_t antifuzzStringOff[SHA512_DIGEST_LENGTH] = {0x0b, 0x43, 0x27, 0x02, 0x23, 0x48, 0xe9, 0xbf, 0x1b, 0x86, 0x8b, 0xca, 0x32, 0x6f, 0xc8, 0x8d, 0x40, 0x6d, 0x28, 0xca, 0xdb, 0xa5, 0x09, 0x3f, 0x99, 0x05, 0xea, 0x90, 0x47, 0x8d, 0x75, 0xed, 0xa1, 0x04, 0xeb, 0x08, 0xc5, 0x6a, 0xca, 0xb2, 0xda, 0xc0, 0x91, 0x10, 0x18, 0x4b, 0x5c, 0xc9, 0x31, 0xf8, 0xd0, 0x56, 0x7c, 0xfb, 0xb1, 0x02, 0xe9, 0xcf, 0x8b, 0xb1, 0x67, 0xf7, 0x3a, 0xba};
static uint8_t antifuzzString1[SHA512_DIGEST_LENGTH] = {0x4d, 0xff, 0x4e, 0xa3, 0x40, 0xf0, 0xa8, 0x23, 0xf1, 0x5d, 0x3f, 0x4f, 0x01, 0xab, 0x62, 0xea, 0xe0, 0xe5, 0xda, 0x57, 0x9c, 0xcb, 0x85, 0x1f, 0x8d, 0xb9, 0xdf, 0xe8, 0x4c, 0x58, 0xb2, 0xb3, 0x7b, 0x89, 0x90, 0x3a, 0x74, 0x0e, 0x1e, 0xe1, 0x72, 0xda, 0x79, 0x3a, 0x6e, 0x79, 0xd5, 0x60, 0xe5, 0xf7, 0xf9, 0xbd, 0x05, 0x8a, 0x12, 0xa2, 0x80, 0x43, 0x3e, 0xd6, 0xfa, 0x46, 0x51, 0x0a};
static uint8_t antifuzzString0[SHA512_DIGEST_LENGTH] = {0x31, 0xbc, 0xa0, 0x20, 0x94, 0xeb, 0x78, 0x12, 0x6a, 0x51, 0x7b, 0x20, 0x6a, 0x88, 0xc7, 0x3c, 0xfa, 0x9e, 0xc6, 0xf7, 0x04, 0xc7, 0x03, 0x0d, 0x18, 0x21, 0x2c, 0xac, 0xe8, 0x20, 0xf0, 0x25, 0xf0, 0x0b, 0xf0, 0xea, 0x68, 0xdb, 0xf3, 0xf3, 0xa5, 0x43, 0x6c, 0xa6, 0x3b, 0x53, 0xbf, 0x7b, 0xf8, 0x0a, 0xd8, 0xd5, 0xde, 0x7d, 0x83, 0x59, 0xd0, 0xb7, 0xfe, 0xd9, 0xdb, 0xc3, 0xab, 0x99};

#endif
#endif

/* antifuzz.tpl.c file */
#pragma GCC push_options
#pragma GCC optimize ("-Ofast")
#pragma GCC target ("arch=broadwell")
#include <stdio.h>
#include <string.h>
#include <sys/wait.h> 
#include <stdint.h>
#include <stdlib.h>
#include <signal.h>
#include <assert.h>
#include <unistd.h>
#include <utmpx.h>
#if USE_HASH_CMP
#endif
#if REPLACE_UTMP
#include <utmpx.h>
#include <utmp.h>
#endif
#if USE_ENCRYPT_DECRYPT
#define CBC 1
#ifndef _AES_H_
#define _AES_H_

#include <stdint.h>

// #define the macros below to 1/0 to enable/disable the mode of operation.
//
// CBC enables AES encryption in CBC-mode of operation.
// CTR enables encryption in counter-mode.
// ECB enables the basic ECB 16-byte block algorithm. All can be enabled simultaneously.

// The #ifndef-guard allows it to be configured before #include'ing or at compile time.
#ifndef CBC
  #define CBC 1
#endif

#ifndef ECB
  #define ECB 1
#endif

#ifndef CTR
  #define CTR 1
#endif


//#define AES128 1
//#define AES192 1
#define AES256 1

#define AES_BLOCKLEN 16 //Block length in bytes AES is 128b block only

#if defined(AES256) && (AES256 == 1)
    #define AES_KEYLEN 32
    #define AES_keyExpSize 240
#elif defined(AES192) && (AES192 == 1)
    #define AES_KEYLEN 24
    #define AES_keyExpSize 208
#else
    #define AES_KEYLEN 16   // Key length in bytes
    #define AES_keyExpSize 176
#endif

struct AES_ctx
{
  uint8_t RoundKey[AES_keyExpSize];
#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
  uint8_t Iv[AES_BLOCKLEN];
#endif
};

void AES_init_ctx(struct AES_ctx* ctx, const uint8_t* key);
#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
void AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv);
void AES_ctx_set_iv(struct AES_ctx* ctx, const uint8_t* iv);
#endif

#if defined(ECB) && (ECB == 1)
// buffer size is exactly AES_BLOCKLEN bytes; 
// you need only AES_init_ctx as IV is not used in ECB 
// NB: ECB is considered insecure for most uses
void AES_ECB_encrypt(struct AES_ctx* ctx, uint8_t* buf);
void AES_ECB_decrypt(struct AES_ctx* ctx, uint8_t* buf);

#endif // #if defined(ECB) && (ECB == !)


#if defined(CBC) && (CBC == 1)
// buffer size MUST be mutile of AES_BLOCKLEN;
// Suggest https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7 for padding scheme
// NOTES: you need to set IV in ctx via AES_init_ctx_iv() or AES_ctx_set_iv()
//        no IV should ever be reused with the same key 
void AES_CBC_encrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, uint32_t length);
void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, uint32_t length);

#endif // #if defined(CBC) && (CBC == 1)


#if defined(CTR) && (CTR == 1)

// Same function for encrypting as for decrypting. 
// IV is incremented for every block, and used after encryption as XOR-compliment for output
// Suggesting https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7 for padding scheme
// NOTES: you need to set IV in ctx with AES_init_ctx_iv() or AES_ctx_set_iv()
//        no IV should ever be reused with the same key 
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, uint32_t length);

#endif // #if defined(CTR) && (CTR == 1)


#endif //_AES_H_

/*

This is an implementation of the AES algorithm, specifically ECB, CTR and CBC mode.
Block size can be chosen in aes.h - available choices are AES128, AES192, AES256.

The implementation is verified against the test vectors in:
  National Institute of Standards and Technology Special Publication 800-38A 2001 ED

ECB-AES128
----------

  plain-text:
    6bc1bee22e409f96e93d7e117393172a
    ae2d8a571e03ac9c9eb76fac45af8e51
    30c81c46a35ce411e5fbc1191a0a52ef
    f69f2445df4f9b17ad2b417be66c3710

  key:
    2b7e151628aed2a6abf7158809cf4f3c

  resulting cipher
    3ad77bb40d7a3660a89ecaf32466ef97 
    f5d3d58503b9699de785895a96fdbaaf 
    43b1cd7f598ece23881b00e3ed030688 
    7b0c785e27e8ad3f8223207104725dd4 


NOTE:   String length must be evenly divisible by 16byte (str_len % 16 == 0)
        You should pad the end of the string with zeros if this is not the case.
        For AES192/256 the key size is proportionally larger.

*/


/*****************************************************************************/
/* Includes:                                                                 */
/*****************************************************************************/
#include <stdint.h>
#include <string.h> // CBC mode, for memset

/*****************************************************************************/
/* Defines:                                                                  */
/*****************************************************************************/
// The number of columns comprising a state in AES. This is a constant in AES. Value=4
#define Nb 4

#if defined(AES256) && (AES256 == 1)
    #define Nk 8
    #define Nr 14
#elif defined(AES192) && (AES192 == 1)
    #define Nk 6
    #define Nr 12
#else
    #define Nk 4        // The number of 32 bit words in a key.
    #define Nr 10       // The number of rounds in AES Cipher.
#endif

// jcallan@github points out that declaring Multiply as a function 
// reduces code size considerably with the Keil ARM compiler.
// See this link for more information: https://github.com/kokke/tiny-AES-C/pull/3
#ifndef MULTIPLY_AS_A_FUNCTION
  #define MULTIPLY_AS_A_FUNCTION 0
#endif




/*****************************************************************************/
/* Private variables:                                                        */
/*****************************************************************************/
// state - array holding the intermediate results during decryption.
typedef uint8_t state_t[4][4];



// The lookup-tables are marked const so they can be placed in read-only storage instead of RAM
// The numbers below can be computed dynamically trading ROM for RAM - 
// This can be useful in (embedded) bootloader applications, where ROM is often limited.
static const uint8_t sbox[256] = {
  //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

static const uint8_t rsbox[256] = {
  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };

// The round constant word array, Rcon[i], contains the values given by 
// x to the power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8)
static const uint8_t Rcon[11] = {
  0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };

/*
 * Jordan Goulder points out in PR #12 (https://github.com/kokke/tiny-AES-C/pull/12),
 * that you can remove most of the elements in the Rcon array, because they are unused.
 *
 * From Wikipedia's article on the Rijndael key schedule @ https://en.wikipedia.org/wiki/Rijndael_key_schedule#Rcon
 * 
 * "Only the first some of these constants are actually used – up to rcon[10] for AES-128 (as 11 round keys are needed), 
 *  up to rcon[8] for AES-192, up to rcon[7] for AES-256. rcon[0] is not used in AES algorithm."
 */


/*****************************************************************************/
/* Private functions:                                                        */
/*****************************************************************************/
/*
static uint8_t getSBoxValue(uint8_t num)
{
  return sbox[num];
}
*/
#define getSBoxValue(num) (sbox[(num)])
/*
static uint8_t getSBoxInvert(uint8_t num)
{
  return rsbox[num];
}
*/
#define getSBoxInvert(num) (rsbox[(num)])

// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states. 
static void KeyExpansion(uint8_t* RoundKey, const uint8_t* Key)
{
  unsigned i, j, k;
  uint8_t tempa[4]; // Used for the column/row operations
  
  // The first round key is the key itself.
  for (i = 0; i < Nk; ++i)
  {
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
  }

  // All other round keys are found from the previous round keys.
  for (i = Nk; i < Nb * (Nr + 1); ++i)
  {
    {
      k = (i - 1) * 4;
      tempa[0]=RoundKey[k + 0];
      tempa[1]=RoundKey[k + 1];
      tempa[2]=RoundKey[k + 2];
      tempa[3]=RoundKey[k + 3];

    }

    if (i % Nk == 0)
    {
      // This function shifts the 4 bytes in a word to the left once.
      // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]

      // Function RotWord()
      {
        k = tempa[0];
        tempa[0] = tempa[1];
        tempa[1] = tempa[2];
        tempa[2] = tempa[3];
        tempa[3] = k;
      }

      // SubWord() is a function that takes a four-byte input word and 
      // applies the S-box to each of the four bytes to produce an output word.

      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
        tempa[1] = getSBoxValue(tempa[1]);
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }

      tempa[0] = tempa[0] ^ Rcon[i/Nk];
    }
#if defined(AES256) && (AES256 == 1)
    if (i % Nk == 4)
    {
      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
        tempa[1] = getSBoxValue(tempa[1]);
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }
    }
#endif
    j = i * 4; k=(i - Nk) * 4;
    RoundKey[j + 0] = RoundKey[k + 0] ^ tempa[0];
    RoundKey[j + 1] = RoundKey[k + 1] ^ tempa[1];
    RoundKey[j + 2] = RoundKey[k + 2] ^ tempa[2];
    RoundKey[j + 3] = RoundKey[k + 3] ^ tempa[3];
  }
}

void AES_init_ctx(struct AES_ctx* ctx, const uint8_t* key)
{
  KeyExpansion(ctx->RoundKey, key);
}
#if (defined(CBC) && (CBC == 1)) || (defined(CTR) && (CTR == 1))
void AES_init_ctx_iv(struct AES_ctx* ctx, const uint8_t* key, const uint8_t* iv)
{
  KeyExpansion(ctx->RoundKey, key);
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
}
void AES_ctx_set_iv(struct AES_ctx* ctx, const uint8_t* iv)
{
  memcpy (ctx->Iv, iv, AES_BLOCKLEN);
}
#endif

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round,state_t* state,uint8_t* RoundKey)
{
  uint8_t i,j;
  for (i = 0; i < 4; ++i)
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];
    }
  }
}

// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
    }
  }
}

// The ShiftRows() function shifts the rows in the state to the left.
// Each row is shifted with different offset.
// Offset = Row number. So the first row is not shifted.
static void ShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to left  
  temp           = (*state)[0][1];
  (*state)[0][1] = (*state)[1][1];
  (*state)[1][1] = (*state)[2][1];
  (*state)[2][1] = (*state)[3][1];
  (*state)[3][1] = temp;

  // Rotate second row 2 columns to left  
  temp           = (*state)[0][2];
  (*state)[0][2] = (*state)[2][2];
  (*state)[2][2] = temp;

  temp           = (*state)[1][2];
  (*state)[1][2] = (*state)[3][2];
  (*state)[3][2] = temp;

  // Rotate third row 3 columns to left
  temp           = (*state)[0][3];
  (*state)[0][3] = (*state)[3][3];
  (*state)[3][3] = (*state)[2][3];
  (*state)[2][3] = (*state)[1][3];
  (*state)[1][3] = temp;
}

static uint8_t xtime(uint8_t x)
{
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
}

// MixColumns function mixes the columns of the state matrix
static void MixColumns(state_t* state)
{
  uint8_t i;
  uint8_t Tmp, Tm, t;
  for (i = 0; i < 4; ++i)
  {  
    t   = (*state)[i][0];
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
    Tm  = (*state)[i][3] ^ t ;              Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
  }
}

// Multiply is used to multiply numbers in the field GF(2^8)
// Note: The last call to xtime() is unneeded, but often ends up generating a smaller binary
//       The compiler seems to be able to vectorize the operation better this way.
//       See https://github.com/kokke/tiny-AES-c/pull/34
#if MULTIPLY_AS_A_FUNCTION
static uint8_t Multiply(uint8_t x, uint8_t y)
{
  return (((y & 1) * x) ^
       ((y>>1 & 1) * xtime(x)) ^
       ((y>>2 & 1) * xtime(xtime(x))) ^
       ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^
       ((y>>4 & 1) * xtime(xtime(xtime(xtime(x)))))); /* this last call to xtime() can be omitted */
  }
#else
#define Multiply(x, y)                                \
      (  ((y & 1) * x) ^                              \
      ((y>>1 & 1) * xtime(x)) ^                       \
      ((y>>2 & 1) * xtime(xtime(x))) ^                \
      ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \
      ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))   \

#endif

// MixColumns function mixes the columns of the state matrix.
// The method used to multiply may be difficult to understand for the inexperienced.
// Please use the references to gain more information.
static void InvMixColumns(state_t* state)
{
  int i;
  uint8_t a, b, c, d;
  for (i = 0; i < 4; ++i)
  { 
    a = (*state)[i][0];
    b = (*state)[i][1];
    c = (*state)[i][2];
    d = (*state)[i][3];

    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
  }
}


// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(state_t* state)
{
  uint8_t i, j;
  for (i = 0; i < 4; ++i)
  {
    for (j = 0; j < 4; ++j)
    {
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
    }
  }
}

static void InvShiftRows(state_t* state)
{
  uint8_t temp;

  // Rotate first row 1 columns to right  
  temp = (*state)[3][1];
  (*state)[3][1] = (*state)[2][1];
  (*state)[2][1] = (*state)[1][1];
  (*state)[1][1] = (*state)[0][1];
  (*state)[0][1] = temp;

  // Rotate second row 2 columns to right 
  temp = (*state)[0][2];
  (*state)[0][2] = (*state)[2][2];
  (*state)[2][2] = temp;

  temp = (*state)[1][2];
  (*state)[1][2] = (*state)[3][2];
  (*state)[3][2] = temp;

  // Rotate third row 3 columns to right
  temp = (*state)[0][3];
  (*state)[0][3] = (*state)[1][3];
  (*state)[1][3] = (*state)[2][3];
  (*state)[2][3] = (*state)[3][3];
  (*state)[3][3] = temp;
}


// Cipher is the main function that encrypts the PlainText.
static void Cipher(state_t* state, uint8_t* RoundKey)
{
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(0, state, RoundKey); 
  
  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr-1 rounds are executed in the loop below.
  for (round = 1; round < Nr; ++round)
  {
    SubBytes(state);
    ShiftRows(state);
    MixColumns(state);
    AddRoundKey(round, state, RoundKey);
  }
  
  // The last round is given below.
  // The MixColumns function is not here in the last round.
  SubBytes(state);
  ShiftRows(state);
  AddRoundKey(Nr, state, RoundKey);
}

static void InvCipher(state_t* state,uint8_t* RoundKey)
{
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(Nr, state, RoundKey); 

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr-1 rounds are executed in the loop below.
  for (round = (Nr - 1); round > 0; --round)
  {
    InvShiftRows(state);
    InvSubBytes(state);
    AddRoundKey(round, state, RoundKey);
    InvMixColumns(state);
  }
  
  // The last round is given below.
  // The MixColumns function is not here in the last round.
  InvShiftRows(state);
  InvSubBytes(state);
  AddRoundKey(0, state, RoundKey);
}


/*****************************************************************************/
/* Public functions:                                                         */
/*****************************************************************************/
#if defined(ECB) && (ECB == 1)


void AES_ECB_encrypt(struct AES_ctx *ctx, uint8_t* buf)
{
  // The next function call encrypts the PlainText with the Key using AES algorithm.
  Cipher((state_t*)buf, ctx->RoundKey);
}

void AES_ECB_decrypt(struct AES_ctx* ctx, uint8_t* buf)
{
  // The next function call decrypts the PlainText with the Key using AES algorithm.
  InvCipher((state_t*)buf, ctx->RoundKey);
}


#endif // #if defined(ECB) && (ECB == 1)





#if defined(CBC) && (CBC == 1)


static void XorWithIv(uint8_t* buf, uint8_t* Iv)
{
  uint8_t i;
  for (i = 0; i < AES_BLOCKLEN; ++i) // The block in AES is always 128bit no matter the key size
  {
    buf[i] ^= Iv[i];
  }
}

void AES_CBC_encrypt_buffer(struct AES_ctx *ctx,uint8_t* buf, uint32_t length)
{
  uintptr_t i;
  uint8_t *Iv = ctx->Iv;
  for (i = 0; i < length; i += AES_BLOCKLEN)
  {
    XorWithIv(buf, Iv);
    Cipher((state_t*)buf, ctx->RoundKey);
    Iv = buf;
    buf += AES_BLOCKLEN;
    //printf("Step %d - %d", i/16, i);
  }
  /* store Iv in ctx for next call */
  memcpy(ctx->Iv, Iv, AES_BLOCKLEN);
}

void AES_CBC_decrypt_buffer(struct AES_ctx* ctx, uint8_t* buf,  uint32_t length)
{
  uintptr_t i;
  uint8_t storeNextIv[AES_BLOCKLEN];
  for (i = 0; i < length; i += AES_BLOCKLEN)
  {
    memcpy(storeNextIv, buf, AES_BLOCKLEN);
    InvCipher((state_t*)buf, ctx->RoundKey);
    XorWithIv(buf, ctx->Iv);
    memcpy(ctx->Iv, storeNextIv, AES_BLOCKLEN);
    buf += AES_BLOCKLEN;
  }

}

#endif // #if defined(CBC) && (CBC == 1)



#if defined(CTR) && (CTR == 1)

/* Symmetrical operation: same function for encrypting as for decrypting. Note any IV/nonce should never be reused with the same key */
void AES_CTR_xcrypt_buffer(struct AES_ctx* ctx, uint8_t* buf, uint32_t length)
{
  uint8_t buffer[AES_BLOCKLEN];
  
  unsigned i;
  int bi;
  for (i = 0, bi = AES_BLOCKLEN; i < length; ++i, ++bi)
  {
    if (bi == AES_BLOCKLEN) /* we need to regen xor compliment in buffer */
    {
      
      memcpy(buffer, ctx->Iv, AES_BLOCKLEN);
      Cipher((state_t*)buffer,ctx->RoundKey);

      /* Increment Iv and handle overflow */
      for (bi = (AES_BLOCKLEN - 1); bi >= 0; --bi)
      {
	/* inc will owerflow */
        if (ctx->Iv[bi] == 255)
	{
          ctx->Iv[bi] = 0;
          continue;
        } 
        ctx->Iv[bi] += 1;
        break;   
      }
      bi = 0;
    }

    buf[i] = (buf[i] ^ buffer[bi]);
  }
}

#endif // #if defined(CTR) && (CTR == 1)


#endif
#if USE_SIGNAL_TAMPERING
#include <setjmp.h>
#include <sys/ptrace.h>
#endif

#if ENABLE_SLEEP && SLEEP_METHOD == SLEEP_METHOD_BUSY_WAITING
#include <sys/time.h>
#include <time.h> 
#endif

#if FOR_CGC
#include <libcgc.h>
/* $Id: rand.c,v 1.1.1.1 2006/08/23 17:03:06 pefo Exp $ */

/*
 * Copyright (c) 2000-2002 Opsycon AB  (www.opsycon.se)
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Opsycon AB.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <stdlib.h>

unsigned long int rand_next = 1;

/*
 *  int rand()
 *      Taken from the K&R C programming language book. Page 46.
 *      returns a pseudo-random integer of 0..32767. Note that
 *      this is compatible with the System V function rand(), not
 *      with the bsd function rand() that returns 0..(2**31)-1.
 */
unsigned int 
rand ()
{
  rand_next = rand_next * 1103515245 + 12345;
  return (unsigned int)(rand_next);
}

/*
 *  srand(seed)
 *      companion routine to rand(). Initializes the seed.
 */
void
srand(unsigned int seed)
{
  rand_next = seed;
}

int transmit_all(int fd, const char *buf, const size_t size) {
    size_t sent = 0;
    size_t sent_now = 0;
    int ret;

    if (!buf) 
        return 1;

    if (!size)
        return 2;

    while (sent < size) {
        ret = transmit(fd, buf + sent, size - sent, &sent_now);
        if (sent_now == 0) {
            //should never return until at least something was transmitted
            //so consider this an error too
            return 3;
        }
        if (ret != 0) {
            return 3;
        }
        sent += sent_now;
    }

    return 0;
}
#else
#include <sys/stat.h>
#endif

#if USE_ENCRYPT_DECRYPT
struct AES_ctx aes_ctx;
uint8_t key[32];
#endif

#if USE_FILLBITMAP
#define CTX_NUM_INSTRUCTIONS 128
#define NUM_FILLBITMAP 0

/* antiafl.c */

struct context_s;
typedef struct context_s context_t;
typedef void (*obfuscation_call_bitmap)(context_t*, uint8_t);
uint8_t bitmap_range[] = {1, 2, 4, 8, 16, 32, 64, 128};



obfuscation_call_bitmap ptr_table[] = {

};

struct context_s {
  size_t ip;
  uint32_t offsets[CTX_NUM_INSTRUCTIONS];
  obfuscation_call_bitmap *ptrs;
};

context_t* new_context() {
  context_t* ctx = (context_t*)malloc(sizeof(context_t));
  if(ctx == NULL) {
    exit(-2);
  }
  ctx->ip = 0;
  for(size_t i=0; i<CTX_NUM_INSTRUCTIONS; i++){
    ctx->offsets[i] = 1 + (rand() % (NUM_FILLBITMAP-1));
  }
  ctx->offsets[CTX_NUM_INSTRUCTIONS-1] = 0;
  ctx->ptrs = ptr_table;
  return ctx;
}

void a_0(context_t* ctx, uint8_t ret){
  return;
}



void context_step(context_t* ctx){
  ctx->ptrs[ctx->offsets[ctx->ip++ % CTX_NUM_INSTRUCTIONS]](ctx, 0);
}
/* antiafl.c end */
#endif

#if USE_HEAVYWEIGHTBB
#define NUM_HEAVYWEIGHTBB 0

typedef int (*obfuscation_call_heavyweight)(unsigned char* buf, unsigned int len);



obfuscation_call_heavyweight functions_array[NUM_HEAVYWEIGHTBB] = {
  
};

#endif

#if USE_HASH_CMP
/* antifuzz.c */
uint8_t antifuzz_hash_cmp(uint8_t hash1[SHA512_DIGEST_LENGTH], uint8_t hash2[SHA512_DIGEST_LENGTH]) {
  uint8_t equal = 1;
  for(int i = 0; i < SHA512_DIGEST_LENGTH; i++) {
    if((uint8_t)hash1[i] != (uint8_t)hash2[i]) {
      equal = 0;
      break;
    }
  }
  return equal;
}

uint8_t antifuzz_str_equal(char* variableStr, uint8_t constHash[SHA512_DIGEST_LENGTH]) {
  uint8_t out[SHA512_DIGEST_LENGTH];
  SHA512((uint8_t*)variableStr, strlen(variableStr), out);
  return antifuzz_hash_cmp(out, constHash);
}

uint8_t antifuzz_equal(uint8_t *in, size_t size, uint8_t constHash[SHA512_DIGEST_LENGTH]) {
  uint8_t out[SHA512_DIGEST_LENGTH];
  SHA512(in, size, out);
  return antifuzz_hash_cmp(out, constHash);
}

uint8_t antifuzz_char_equal(char value, uint8_t constHash[SHA512_DIGEST_LENGTH]) {
  return antifuzz_equal((uint8_t*)&value, sizeof(char), constHash);
}

uint8_t antifuzz_int_equal(int value, uint8_t constHash[SHA512_DIGEST_LENGTH]) {
  return antifuzz_equal((uint8_t*)&value, sizeof(int), constHash);
}

uint8_t antifuzz_long_equal(long value, uint8_t constHash[SHA512_DIGEST_LENGTH]) {
  return antifuzz_equal((uint8_t*)&value, sizeof(long), constHash);
}

uint8_t antifuzz_long_long_equal(long long value, uint8_t constHash[SHA512_DIGEST_LENGTH]) {
  return antifuzz_equal((uint8_t*)&value, sizeof(long long), constHash);
}

#endif

void _antifuzz_sleep(unsigned int sleepms) {
#if ENABLE_SLEEP
#if SLEEP_METHOD == SLEEP_METHOD_BUSY_WAITING
    //usleep for 20ms would be enough, but what if sleeps are patched out automatically?
    //instead, let's loop until the time is reached (busy waiting)
    double ms_start, ms_stop;
    struct timeval  tv;
    gettimeofday(&tv, NULL);
    ms_start = (tv.tv_sec) * 1000 + (tv.tv_usec) / 1000 ;
    ms_stop = ms_start;
    while(ms_stop - ms_start < sleepms) {
      gettimeofday(&tv, NULL);
      ms_stop = (tv.tv_sec) * 1000 + (tv.tv_usec) / 1000 ;
    }
#else
    int sleeptime = (sleepms / 1000) + ((sleepms % 1000) > 0);
    sleep(sleeptime);
#endif
#endif
}

void antifuzz_onerror() {
#if USE_ANTIFUZZ
  _antifuzz_sleep(ANTIFUZZ_SLEEP);
#endif
}

#if USE_SIGNAL_TAMPERING

unsigned int antifuzz_signal_handlers[] = {
  SIGHUP, SIGILL, SIGABRT, SIGFPE, SIGSEGV
};

// This handler is called when the program really crashed.
// In that case, instead of crashing, exceed the timeout of the fuzzer.
// If this is not running in a fuzzer, it will crash as usual.
void antifuzz_signal_handler(int signo) {
#if ENABLE_PRINTF
  printf("caught real signal\n");
#endif
  signal(signo, SIG_DFL);
#if IF_CRASH_THEN_DO == ANTIFUZZ_CRASH_ACTION_EXIT_GRACEFULLY
#if ENABLE_PRINTF
  printf("exiting gracefully\n");
#endif
  exit(0);
#else //sleep until timeout
  _antifuzz_sleep(ANTIFUZZ_SLEEP_CRASH);
#if ENABLE_PRINTF
  printf("raising signal\n");
#endif
  raise(signo);
#endif
}

void antifuzz_install_signals() {
#if ENABLE_PRINTF
  printf("installing signals\n");
#endif
  for(int i = 0; i < sizeof(antifuzz_signal_handlers) / sizeof(antifuzz_signal_handlers[0]); i++) {
    signal(antifuzz_signal_handlers[i], antifuzz_signal_handler);
  }
  signal(SIGSEGV, antifuzz_signal_handler);
}

void antifuzz_uninstall_signals() {
#if ENABLE_PRINTF
  printf("uninstalling signals\n");
#endif
  for(int i = 0; i < sizeof(antifuzz_signal_handlers) / sizeof(antifuzz_signal_handlers[0]); i++) {
    signal(antifuzz_signal_handlers[i], SIG_DFL);
  }
}

int antifuzz_signal_testing_result  = 0;
jmp_buf jbuf;

void antifuzz_signal_tester(int signo) {
#if ENABLE_PRINTF
  printf("antifuzz_signal_tester\n");
#endif
  antifuzz_signal_testing_result = 1;
  longjmp(jbuf, 1);
}

int antifuzz_crash() {
  char *a = NULL;
  if(!setjmp(jbuf)) {
    //*a = 1;
    assert(0);
    return 0;
  } else {
    return 1;
  }
  return 2;
}

void antifuzz_signal_tamper_test() {
  // zzuf overwrites the signal handler
  // if we can reach our own signal handler, everything is fine
  // if not, zzuf is active: terminate program.
#if ENABLE_PRINTF
  printf("antifuzz_signal_tamper_test\n");
#endif
  signal(SIGABRT, antifuzz_signal_tester);
  //signal(SIGILL, antifuzz_signal_tester); //clang generates illegal instruction (ud2), 
                                        //probably as a warning because of char *a = NULL; *a = 1;
  //raise(SIGSEGV);
  antifuzz_crash();

  //antifuzz_signal_testing_result is 1 when our own signal handler was called
  //also, we will probably never reach this if zzuf signal handler was active (because it terminates the program)
  if(antifuzz_signal_testing_result == 0) {
    exit(0);
  }
  signal(SIGABRT, SIG_DFL);
  //signal(SIGILL, SIG_DFL);
}

/* check if ptrace is used to catch signals (honggfuzz does this) */
void antifuzz_ptrace_test() {
  pid_t pid;
  pid = fork();
  if(pid != 0) {
    // parent
#if ENABLE_PRINTF
    printf("waiting for children\n");
#endif
    wait(0); //wait until all children are dead
#if ENABLE_PRINTF
    printf("my wait has ended, detaching\n");
#endif
    ptrace(PTRACE_DETACH, pid, 0, 0); //detach ptrace
    exit(0);
  } else {
    //child
    if(ptrace (PTRACE_TRACEME, 0, NULL, NULL) == -1) {
      antifuzz_crash();
    }
    setsid();
  }
}
#endif

void antifuzz_init(char* filePath, unsigned int flags) {
#if USE_ANTIFUZZ
  _antifuzz_init(filePath, -1, flags);
#endif
}

void antifuzz_init_cgc(char **buffer, int size, unsigned int flags) {
  *buffer =  _antifuzz_init(*buffer, size, flags);
#if USE_ENCRYPT_DECRYPT
  uint64_t fileSize = size;
  //printf("filesize: %d\n", fileSize);

  // else: everything is fine, encrypt and decrypt
  uint64_t fileSizePadded;
  unsigned char *dst;
  // aes.c does not support padding, we have to do it ourselves
  if(fileSize % 16 > 0) {
    int extraBytes = (16 - (fileSize % 16));
    fileSizePadded = fileSize + extraBytes;
    dst = (unsigned char*)malloc(fileSizePadded);
    memcpy(dst, *buffer, fileSize);
    // pad the rest with 0x41 or 0x00 or whatever, doesn't matter
    for(int i = fileSize; i < fileSizePadded; i++) {
      dst[i] = 0x41;
    }
  } else {
    // no padding necessary
    fileSizePadded = fileSize;
    dst = (unsigned char*)malloc(fileSizePadded);
  }
  uint8_t key[32];
  // generate random key (seeded with file content)
  for(int i = 0; i < 32; i++) {
    key[i] = rand() % 256;
    //printf("key[%d] = %02x\n", i, (unsigned char)key[i]);
  }
  struct AES_ctx aes_ctx;
  AES_init_ctx(&aes_ctx, key);
  //printf("input: %s (%d)\n", dst, fileSizePadded);
  //encrypt file content in 16 byte blocks
  for(int i = 0; i < (fileSizePadded / 16); i++) {
    AES_ECB_encrypt(&aes_ctx, dst+(i*16));
  }
  //printf("encrypted: %02x %02x\n", dst[0], dst[1]);
  //decrypt file content
  for(int i = 0; i < (fileSizePadded / 16); i++) {
    AES_ECB_decrypt(&aes_ctx, dst+(i*16));
  }
  //remove padding
  memcpy(*buffer, dst, fileSize);
  free(dst);
#endif
}

#if !FOR_CGC

#define MAX_AES_BLOCK_SIZE (1024)

void antifuzz_encrypt_decrypt_buf(char *ptr, size_t fileSize) {  
#if USE_ENCRYPT_DECRYPT
  //printf("antifuzz_encrypt_decrypt_buf\n");
  uint32_t aesFileSize = (fileSize > MAX_AES_BLOCK_SIZE) ? (MAX_AES_BLOCK_SIZE) : (fileSize);
  uint64_t fileSizePadded;
  unsigned char *dst;
  // aes.c does not support padding, we have to do it ourselves
  if(aesFileSize % 16 > 0) {
    int extraBytes = (16 - (aesFileSize % 16));
    fileSizePadded = aesFileSize + extraBytes;
    dst = (unsigned char*)malloc(fileSizePadded);
    memcpy(dst, ptr, aesFileSize);
    // pad the rest with 0x41 or 0x00 or whatever, doesn't matter
    for(int i = aesFileSize; i < fileSizePadded; i++) {
      dst[i] = 0x41;
    }
  } else {
    // no padding necessary
    fileSizePadded = aesFileSize;
    dst = (unsigned char*)malloc(fileSizePadded);
    memcpy(dst, ptr, aesFileSize);
  }
  //printf("input: %s (%d)\n", dst, fileSizePadded);
  //encrypt file content in 16 byte blocks
  for(int i = 0; i < (fileSizePadded / 16); i++) {
    AES_ECB_encrypt(&aes_ctx, dst+(i*16));
  }
  //printf("encrypted: %02x %02x\n", dst[0], dst[1]);
  //decrypt file content
  for(int i = 0; i < (fileSizePadded / 16); i++) {
    AES_ECB_decrypt(&aes_ctx, dst+(i*16));
  }
  //remove padding
  memcpy(ptr, dst, aesFileSize);
  free(dst);
  //printf("decrypted: %s\n", ptr);
#endif
}

// this is a call like fread() to read the content of a file, 
// but we encrypt & decrypt it to confuse symbolic execution engines
size_t antifuzz_fread ( void * ptr, size_t size, size_t count, FILE * stream ) {
#if USE_ENCRYPT_DECRYPT
  size_t numRead = fread(ptr, size, count, stream);
  //printf("antifuzz_read: %d\n", numRead);
  // returned because of error?
  if(numRead != count && !feof(stream)) {
    return numRead;
  }
  uint64_t fileSize = size*numRead;
  //printf("filesize: %d\n", fileSize);
  // else: everything is fine, encrypt and decrypt
  antifuzz_encrypt_decrypt_buf(ptr, fileSize);
  return numRead;
#else
  return fread(ptr, size, count, stream);
#endif
}

#if REPLACE_UTMP && USE_ENCRYPT_DECRYPT
struct utmpx *antifuzz_getutxent(void) {
  STRUCT_UTMP *u = getutxent();
  antifuzz_encrypt_decrypt_buf(u, sizeof(STRUCT_UTMP));
  return u;
}
#else
struct utmpx *antifuzz_getutxent(void) {
  return getutxent();
}
#endif

#endif //!FOR_CGC

static uint8_t wasInit = 0;
uint32_t seed_mult = 0;
char* fileContentMult = NULL;
#define MAX_FILE_CONTENT_SIZE 512

void antifuzz_exit(unsigned int flags) {
  //printf("antifuzz_exit called\n");
  srand(seed_mult);

#if USE_FILLBITMAP
  if((flags & FLAG_FILLBITMAP) && (NUM_FILLBITMAP >= 2)) {
    context_t* ctx = new_context();
    context_step(ctx);
    free(ctx);
  }
#endif
#if USE_HEAVYWEIGHTBB
  if (flags & FLAG_HEAVWEIGHTBB) {
    for(int i = 0; i < NUM_HEAVYWEIGHTBB; i++) {
      functions_array[i](fileContentMult, MAX_FILE_CONTENT_SIZE);
    }
  }
#endif
}

char* _antifuzz_init(char *filePathOrBuffer, int size, unsigned int flags) {
  wasInit = 1;
#if FOR_CGC
  unsigned int filesize = size;
  filePathOrBuffer = (char*)malloc(filesize);
  if(!filePathOrBuffer) {
    return NULL;
  }
  bzero(filePathOrBuffer, filesize);
  size_t gotBytes;
  receive(STDIN, filePathOrBuffer, size, &gotBytes);
  //read(0, filePathOrBuffer, sizeof( filePathOrBuffer ) - 1 );
  unsigned char* fileContent = (unsigned char*)filePathOrBuffer;
#else
  struct stat st;
  int statErr = stat(filePathOrBuffer, &st);
  if(statErr != 0) {
    return NULL;
  }
  unsigned int filesize = st.st_size;
  FILE *f = fopen(filePathOrBuffer, "r");
  if(!f) {
    return NULL;
  }
  unsigned char *fileContent = (unsigned char*)malloc(filesize);
  if(!fileContent) {
    return NULL;
  }
  int filesizeRead = fread(fileContent, 1, filesize, f);
  if (filesizeRead != filesize) {
    return NULL;
  }
#endif

#if USE_SIGNAL_TAMPERING
  if(flags & FLAG_SIGNAL_TAMPERING) {
    antifuzz_signal_tamper_test();
    antifuzz_ptrace_test();
    antifuzz_install_signals();
  }
#endif

  uint32_t seed = 0;
  //crc32(fileContent, filesize, &seed);
  seed = filesize;
  srand(seed);

#if USE_FILLBITMAP
  if((flags & FLAG_FILLBITMAP) && (NUM_FILLBITMAP >= 2)) {
    context_t* ctx = new_context();
    context_step(ctx);
    free(ctx);
  }
#endif
#if USE_HEAVYWEIGHTBB
  if (flags & FLAG_HEAVWEIGHTBB) {
    for(int i = 0; i < NUM_HEAVYWEIGHTBB; i++) {
      functions_array[i](fileContent, filesize);
    }
  }
#endif
#if FOR_CGC
  return fileContent;
#else
  fclose(f);
  free(fileContent);
#if ENABLE_PRINTF
  //printf("done\n");
#endif
  return NULL;
#endif

}

void antifuzz_deinit() {
#if USE_SIGNAL_TAMPERING
  antifuzz_uninstall_signals();
#endif
}

/* antifuzz.c EOF */
#pragma GCC pop_options


#endif